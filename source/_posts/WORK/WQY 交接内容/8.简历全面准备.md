![Exported image](Exported%20image%2020250328133724-0.png)

自我评价：  
1.已经授权的专利详情
 
履历：  
1.数据库内核开发  
内嵌函数开发：to_char,to_date  
（1）当初设计与比较亮点的功能。  
（2）碰到的问题解决。  
（1）调研手册，PPT技术分享。  
（2）
 
卫星知识：1.数据库整体架构。
    
2.数据库外部接口开发
 
外部java接口开发（AI准备）
   

3.多平台机器支持与项目适配  
（1）机器支持：包括系统修复、  
（2）  
卫星知识：1.c/c++编译，java编译相关。
    
4.快速定位并分析问题
      

5.熟练使用git工具
   

自我评价：

## 1.已经授权的专利详情

题目：密钥管理方法、装置、电子设备及存储介质  
**总结大意**

1. **多层密钥嵌套**：顶层加密中间层，中间层加密底层，底层加密数据。
2. **动态性能评估**：基于效率、资源占用、稳定性、安全性等参数，加权计算每层密钥的性能评分。
3. **智能密钥更新**：根据负载、使用时间/频次、性能评分等条件，动态增减层级或更换加密算法。
4. **泄露应急机制**：若某层发生泄露，在最高泄露层下新增层级并更新下属所有密钥。
 
**简单举例**

1. **密钥层级**：
    
    - **顶层**：使用RSA算法加密中间层密钥。
    - **中间层**：使用AES-GCM加密底层密钥。
    - **底层**：使用ChaCha20加密用户文件。
2. **动态调整**：
    
    - 当系统负载高（如大量用户上传文件），自动增加中间层（如新增一层SM4算法密钥），分担加密压力。
    - 若某层密钥使用超过1年（预设时间），自动替换其加密算法（如将RSA升级为抗量子算法）。
3. **泄露应对**：
    
    - 若检测到中间层AES-GCM密钥泄露，在该层下新增一层（如Camellia算法），并重新生成所有下层密钥，确保泄露层以下数据安全。

**优势**：通过动态优化兼顾性能与安全，适应高并发场景，且泄露时最小化影响范围。
             
# 履历：
 
一.数据库内核开发

## 1.内建函数开发

（1）内建函数to_date  
将 UDR 函数转换为内建函数，涉及处理 yacc，对传入数据的类型进行处理，开发功能的逻辑
 
新的时间格式开发，AD，A.D.，AM，A.M.，BC，B.C.，DAY，DDD，DY，MON，MONTH，PM，P.M. RR，RRRR，Y,YYY，SYYYY
   

（2）内建函数to_char  
W,WW,YEAR,SYEAR
    
## 2.伪表技术开发

（1）伪表代码阅读  
使用Source insight，vscode 看代码  
（2）调研手册，PPT技术分享。
   

## 卫星知识：

### 1.数据库整体架构

1. **连接层**
    
    - 负责与客户端（如应用程序、用户工具）建立连接，处理通信协议和权限验证。
2. **查询处理层**
    
    - **解析器**：检查SQL语法，生成抽象语法树。
    - **优化器**：选择最优执行计划（如索引使用、连接顺序）。
    - **执行引擎**：执行优化后的查询计划，返回结果。
3. **事务管理**
    
    - 确保ACID特性（原子性、一致性、隔离性、持久性），通过锁机制或MVCC处理并发控制。
4. **存储引擎**
    
    - 数据存储的核心模块，管理数据文件、索引结构（如B+树）、缓存（如缓冲池），以及数据压缩、磁盘I/O优化。
5. **存储层**
    
    - 数据持久化到物理介质（如磁盘、SSD），管理文件组织形式（如堆文件、页式存储）。
6. **日志模块**
    
    - 记录事务日志（WAL，预写式日志）和操作日志，用于故障恢复和保证事务持久性。
7. **安全与权限**
    
    - 管理用户认证、访问控制（如角色权限）、数据加密及审计日志。
8. **备份与恢复**
    
    - 提供定期备份、增量备份及灾难恢复机制。
9. **分布式组件（可选）**
    
    - 在分布式数据库中，处理数据分片、副本同步（如Paxos/Raft协议）、跨节点事务（如两阶段提交）。

**关键协作**：用户请求经连接层进入，查询处理层解析优化后，存储引擎读写数据，事务管理确保操作可靠，日志与备份保障数据安全，分布式模块扩展规模。各层协同实现高效、安全的数据管理。
   

### 2.sql 在数据库中执行流程

以下是 **SELECT 语句从传入数据库引擎到执行完毕的全流程详解**，涵盖从客户端请求到结果返回的每一个核心步骤。以典型关系型数据库（如 MySQL、PostgreSQL）为例：

1. **连接建立**
    
    - 客户端通过协议（如 JDBC/ODBC）与数据库建立 TCP 连接。
    - 完成身份认证（用户名、密码校验）和权限检查（确认用户是否有权执行 SELECT 操作）。
2. **SQL 语句传输**
    
    - 客户端将 SQL 语句（如 SELECT * FROM users WHERE age > 25 ORDER BY name LIMIT 10;）发送到数据库服务器。
 
**二、数据库引擎内部处理阶段**

- **词法分析****￼**将 SQL 文本拆分为 Token（关键字、表名、列名、运算符等）。￼示例：SELECT → 关键字，users → 表名，age → 列名，> → 运算符。
- **语法分析****￼**验证 SQL 是否符合语法规则（如 WHERE 后必须有条件表达式），生成**抽象语法树（AST）**。￼_错误处理_：若语法错误（如缺少 FROM），返回错误信息。
- **语义分析****￼**检查逻辑有效性：
    
    - 表 users 是否存在？
    - 列 age 和 name 是否存在于表中？
    - 用户是否有权限访问这些表和列？
 
- **逻辑优化****￼**重写查询以提升效率，例如：
    
    - 消除冗余条件（如 WHERE 1=1）。
    - 子查询展开或转换为 JOIN。
    - 常量表达式预先计算（如 WHERE age > 10+15 → WHERE age > 25）。
- **物理优化****￼**生成候选执行计划，估算每个计划的代价（基于统计信息）：
    
    - **统计信息**：表大小、索引基数、数据分布直方图。
    - **代价模型**：计算 CPU、I/O、内存消耗。
    - **关键决策**：
        
        - 选择访问路径（全表扫描 vs 索引扫描）。
        - 确定 JOIN 顺序和算法（Nested Loop Join、Hash Join、Merge Join）。
        - 是否使用临时表存储中间结果。
- **选择最优执行计划****￼**根据代价模型选择总成本最低的计划。￼_示例_：对 WHERE age > 25，若 age 列有索引且过滤率高，优先使用索引扫描。
 
- 将优化后的逻辑转换为**物理执行计划**（操作符树）：￼-> Limit (取前10条)￼ -> Sort (按 name 排序)￼ -> Filter (age > 25)￼ -> Seq Scan on users (全表扫描)￼￼或（若使用索引）：￼-> Limit￼ -> Sort￼ -> Index Scan using idx_age on users (索引扫描)
 
**4. 执行阶段（Execution Engine）**

- **执行引擎**按计划树自底向上处理数据，采用**迭代器模型**（Volcano Model）：
    
    - 每个操作符（如 Scan、Filter、Sort）实现 Open()、Next()、Close() 方法。
    - 父节点调用子节点的 Next() 获取数据，逐级处理。
- **关键步骤**：
    
    1. **数据访问**：
        
        - **全表扫描**：逐行读取数据页（可能利用缓冲池 Buffer Pool 缓存热数据）。
        - **索引扫描**：通过 B+ 树定位符合条件的数据行（回表查询需根据主键获取完整行数据）。
    2. **过滤（WHERE）**：￼逐行检查 age > 25 条件，丢弃不满足条件的行。
    3. **排序（ORDER BY）**：
        
        - 若数据量小，使用内存排序（如快速排序）。
        - 若数据量大，使用外部归并排序（将数据分块排序后合并）。
    4. **分页（LIMIT）**：￼仅保留前 10 条结果，提前终止后续数据处理。
- **锁与并发控制**：
    
    - 根据隔离级别（如 Read Committed）决定是否加锁或使用 MVCC 多版本快照。
    - 例如：MVCC 下读取事务开始时的数据快照，避免脏读。 
**5. 结果返回**

- 将最终结果集序列化为客户端协议格式（如 MySQL 的二进制协议）。
- 通过 TCP 连接返回给客户端。
- 释放相关资源（如临时表、游标、锁）。 ![Client Client SELECT Connector Connector SQL Parser Parser AST Optimizer Optimizer Executor Executor Storage Storage ](Exported%20image%2020250328133726-1.png)

**四、性能影响因素**

- **索引设计**：索引命中率直接影响数据访问效率。
- **统计信息准确性**：过时的统计信息会导致优化器选择次优计划。
- **硬件资源**：磁盘 I/O 速度、内存大小（减少临时表落盘）。
- **锁竞争**：高并发场景下锁等待会增加延迟。
- **网络延迟**：大数据量结果集传输时间。 
**五、示例全流程分析**  
**SQL**：SELECT name FROM users WHERE age > 25 ORDER BY name LIMIT 10;

- **解析**：确认语法正确，users 表存在且有 name 和 age 列。
- **优化**：统计显示 age 列 50% 数据 >25，优化器选择全表扫描 + 内存排序。
- **执行**：
    
    - 全表扫描 users，过滤出 age > 25 的行。
    - 在内存中对结果按 name 排序。
    - 取前 10 条，返回给客户端。
- **资源释放**：关闭表句柄，释放排序内存。 
**总结**：SELECT 执行流程是数据库核心能力的综合体现，涉及解析、优化、执行三大阶段，每一步的设计（如索引、统计信息、执行算法）均直接影响查询性能。
   

### 3.sql 语句的使用

**1.** **数据查询（****SELECT****）**  
-- 基础查询￼SELECT * FROM users; -- 查询表中所有数据￼SELECT name, age FROM users; -- 查询指定列￼SELECT DISTINCT country FROM customers; -- 去重查询  
-- 条件过滤￼SELECT * FROM products WHERE price > 100; -- 条件筛选￼SELECT * FROM orders WHERE date BETWEEN '2023-01-01' AND '2023-12-31'; -- 范围查询￼SELECT * FROM users WHERE name LIKE 'J%'; -- 模糊匹配（以J开头）  
-- 排序与分页￼SELECT * FROM employees ORDER BY salary DESC; -- 降序排序￼SELECT * FROM products LIMIT 10 OFFSET 5; -- 分页（跳过前5条，取10条）  
-- 聚合统计￼SELECT COUNT(*) FROM orders; -- 统计行数￼SELECT AVG(salary) FROM employees; -- 计算平均值￼SELECT department, SUM(sales) FROM sales_data GROUP BY department; -- 分组聚合
 
**2.** **数据操作（****INSERT/UPDATE/DELETE****）**  
-- 插入数据￼INSERT INTO users (name, age) VALUES ('Alice', 25); -- 插入单条￼INSERT INTO products SELECT * FROM old_products; -- 批量插入  
-- 更新数据￼UPDATE employees SET salary = salary * 1.1 WHERE department = 'IT'; -- 条件更新  
-- 删除数据￼DELETE FROM logs WHERE created_at < '2020-01-01'; -- 条件删除￼TRUNCATE TABLE temp_data; -- 清空表（快速删除所有行）
 
**3.** **表结构管理（****DDL****）**  
-- 创建表￼CREATE TABLE students (￼ id INT PRIMARY KEY AUTO_INCREMENT,￼ name VARCHAR(50) NOT NULL,￼ age INT,￼ enrollment_date DATE DEFAULT CURRENT_DATE￼);  
-- 修改表￼ALTER TABLE employees ADD COLUMN email VARCHAR(100); -- 添加列￼ALTER TABLE products DROP COLUMN discontinued; -- 删除列￼ALTER TABLE orders RENAME TO purchases; -- 重命名表  
-- 删除表￼DROP TABLE backup_data; -- 删除表（不可恢复）
 
**4.** **数据关联（****JOIN****）**  
-- 内连接（交集）￼SELECT orders.id, customers.name ￼FROM orders ￼INNER JOIN customers ON orders.customer_id = customers.id;  
-- 左连接（左表全部 + 右表匹配）￼SELECT employees.name, departments.name ￼FROM employees ￼LEFT JOIN departments ON employees.dept_id = departments.id;  
-- 自连接（同一表关联）￼SELECT e1.name AS employee, e2.name AS manager￼FROM employees e1 ￼LEFT JOIN employees e2 ON e1.manager_id = e2.id;
   

### 4.数据库核心组件

**数据库核心组件详解**  
**一、数据库系统的整体架构**  
数据库系统（以MySQL为例）采用**分层架构**，主要分为 **Server****层（服务层）** 和 **存储引擎层**，此外还包括支持系统运行的**日志模块**、**锁与事务系统**等关键部分。
 
**二、****Server****层组件**

1. **连接器****￼**• **功能**：管理客户端连接，进行身份认证、权限校验，维持长/短连接。￼• **关键机制**：通过wait_timeout参数控制空闲连接超时断开，支持长连接复用以减少资源消耗。
2. **查询缓存（已废弃）****￼**• **历史作用**：缓存SQL语句与结果（Key-Value形式），但因表更新导致缓存频繁失效，MySQL 8.0已移除该功能。
3. **分析器****￼**• **词法分析**：解析SQL语句中的关键字（如SELECT）、表名、列名等。￼• **语法分析**：检查SQL是否符合语法规则，生成语法树供后续处理。
4. **优化器（核心组件）****￼**• **作用**：选择最优执行计划，涉及索引选择、表连接顺序优化（如嵌套循环或哈希连接）等。￼• **优化类型**：￼◦ **逻辑优化**：重写SQL语句（如消除冗余条件）。￼◦ **物理优化**：基于统计信息（表大小、索引选择性）估算I/O和CPU成本，选择成本最低的执行路径。
5. **执行器****￼**• **职责**：按照优化器生成的执行计划调用存储引擎接口执行操作（如读取、插入数据），并返回结果。￼• **权限检查**：执行前验证用户对目标数据的访问权限。
 
**三、存储引擎层**

1. **缓冲池（****Buffer Pool****）****￼**• **作用**：缓存热数据和索引，减少磁盘I/O，提升查询效率。
2. **Redo Log****￼**• **功能**：记录物理修改操作，确保事务持久性（崩溃恢复时重放日志）。
3. **Undo Log****￼**• **用途**：存储数据旧版本，支持事务回滚与MVCC（多版本并发控制）。
4. **锁管理器****￼**• **机制**：管理行级锁、间隙锁，解决并发访问冲突。
 
1. **日志系统****￼**• **Binlog****（服务层）**：记录逻辑操作（如SQL语句），用于主从复制与数据恢复。￼• **两阶段提交**：协调Redo Log（存储引擎层）与Binlog（服务层）的写入，保证事务一致性。
2. **事务系统****￼**• **ACID****实现**：通过Undo/Redo Log、锁机制和MVCC保障原子性、一致性、隔离性与持久性。
3. **物理执行引擎****￼**• **Volcano****模型**：基于迭代器模式（open()-next()-close()接口），逐行处理数据流，主流数据库（如Oracle、MySQL）均采用此模型。
 
**五、数据库系统的完整组成**  
除上述功能组件外，数据库系统还包括：  
13. **硬件**：服务器、存储设备、网络设备，提供运行基础。  
14. **软件**：DBMS（如MySQL）、操作系统、应用程序。  
15. **数据**：结构化或非结构化数据集合。  
16. **用户**：DBA（管理权限与优化）、开发人员（编写SQL）、终端用户（数据操作）。
               

# 二.数据库外部接口开发

## 1.java 数据库接口开发
   

## 卫星知识：

1.java 在 Linux 上编译相关知识

![Linux Java 1. JDK bash java —version # Java —version # javac OpenJDK (N Ubuntu/Debian hf51J) : java -cp bash sudo apt update sudo apt install openjdk—17—jdk • JDK bash # JDK 17 sudo update—alternatives —config java # (ÄII /usr/lib/jvm/java-17—openjdk-amd64) (AD &/.zshrc ) : bash export JAVA_HOME=/usr/lib/jvm/java—17—openjdk—amd64 export PATH— • nem: bash source Ad. bashrc Ei*5Efi bash echo 'public class Hello { public static void main(String[] args) { o Linux!"); > Hello. java bash javac Hello. java # Hello. class bash java Hello src/ # Hello Linux! com/exampte/Main.java L— com/example/utilS/Logger.java bash javac —d ./out src.com/exampte/*. java src.com/exampte/utils/*.java bash ./out com.example.Main 1. (CLASSPATH) bash javac —cp java —cp . : libs/*.jar MyApp.java . : libs/*. jar MyApp # JAR Maven : bash mvn clean compile mvn exec: java example.Main" • Gradle: bash gradie build gradie run bash java -cp ./out com.example.Main bash j avac -encoding UTF-8 Hello. java # Efi bash dos2unix Hello. java # Windows Linux Wit .class JAR Maven Gradle javac Hello. java java Hello java —cp . : jar MyApp mvn clean package gradle build Maven äEjfftöR, ](Exported%20image%2020250328133731-2.png)  

2.java 和 c++的关系  
Java 和 C++ 是两种不同的编程语言，但存在一定的历史渊源和设计理念的关联。以下是它们的核心关系、相似性和主要区别：
 
1. **C++** **对** **Java** **的影响****￼**Java 的语法设计大量借鉴了 C/C++，例如：
    
    - 使用大括号 {} 定义代码块。
    - 分号 ; 结束语句。
    - 类、继承、多态等面向对象语法。
    - 基本数据类型（如 int, float）的命名和操作。
2. **设计目标不同**
    
    - **C++**：面向系统编程，强调性能、灵活性和底层控制（如直接操作内存、指针）。
    - **Java**：面向跨平台应用，强调安全性、可移植性和简化开发（通过 JVM 和垃圾回收机制）。
 
1. **面向对象编程（****OOP****）****￼**均支持类、封装、继承、多态等核心 OOP 特性。
2. **语法相似性****￼**// Java 示例￼public class HelloWorld {￼ public static void main(String[] args) {￼ System.out.println("Hello World!");￼ }￼}￼￼// C++ 示例￼#include <iostream>￼using namespace std;￼￼class HelloWorld {￼public:￼ static void main() {￼ cout << "Hello World!" << endl;￼ }￼};￼￼int main() {￼ HelloWorld::main();￼ return 0;￼}
3. **标准库与生态系统**
    
    - 均提供丰富的标准库（如 Java 的 java.util，C++ 的 STL）。
    - 支持多线程、文件操作、网络编程等通用功能。
 
**三、核心区别**

|   |   |   |
|---|---|---|
|**特性**|**Java**|**C++**|
|**运行机制**|通过 JVM 解释字节码，跨平台运行|直接编译为机器码，依赖操作系统|
|**内存管理**|自动垃圾回收（GC）|手动管理（new/delete）|
|**指针**|不支持指针，使用引用|支持指针和引用|
|**多重继承**|不支持（通过接口替代）|支持|
|**性能**|较低（JVM 开销）|更高（贴近硬件）|
|**平台依赖**|跨平台（Write Once, Run Anywhere）|需为不同平台编译|
|**异常处理**|强制检查异常（Checked Exceptions）|不强制处理异常|
|**泛型**|类型擦除（运行时不可见）|模板（编译时生成代码）|
 
- **Java**：
    
    - 企业级后端（Spring 框架）、Android 应用、大数据（Hadoop）。
    - 示例：支付宝后台、Gmail 服务端。
- **C++**：
    
    - 游戏引擎（Unreal Engine）、高频交易系统、操作系统内核、嵌入式开发。
    - 示例：Photoshop、MySQL 数据库、特斯拉车载系统。
 
- **选** **Java**：快速开发跨平台应用，注重安全性和开发效率。
- **选** **C++**：需要极致性能或底层控制（如硬件交互、实时系统）。
 
**总结**：Java 和 C++ 语法相似，但底层逻辑和适用场景差异显著。Java 是“安全的 C++ 简化版”，而 C++ 是“更自由但更复杂的系统级语言”。
 
3.java 的面相对象编程的形象举例

![(Class) 5" (Object): java class Pet { String name; int age; // F,i-: (AWfi*J) void bark() { System. out. printin ( name public class Main { public static void main (String[] args) { = new Pet(); Pet myDog // new myDog.name = 'EM myDog. age myDog. bark(); 2. (Encapsulation): java class Pet { hunger — private int - 100; food) { public void feed(int If (food > O) { hunger —z food; System. out. ' public class Main { public static void main (String [ ] args) { = new Pet(); pet cat cat. feed (30) ; // feed() // cat. hunger 3. (Inheritance): java class Pet { String name; void bark() { System. out. " ) ; // -f*: E Pet) class Dog extends Pet { @Override void bark() { System. out. printin ( name void wagTait() { System. out. println(name + public class Main { public static void main (String(] args) { = new Dog(); Dog myDog myDog. name — myDog. ba rk(); myDog.wagTait(); // 4. (Polymorphism) : —fih, java class Pet { void bark() { System. out. " ) ; class Dog extends Pet { @Override void bark() { System. out. " ) ; class Cat extends Pet { @Override void bark() { System. out. " ) ; public class Main { public static void main (String[] args) { Pet [l pets = new Pet [2]; pets [0] = new Dog(); pets [1] = new Cat(); pets) { for (Pet pet pet. bark(); LäLäQä! hunger) ](Exported%20image%2020250328133734-3.png)        

# 三.多平台机器支持与项目适配

![1. (-n-&) openssl 2. sw64-swos1.3.o 3. powerRb-AlX7.1 4. (-n-&i) arm64-centos7 5. sw3231-Uos1050d 6. mips64el-EĘM ](Exported%20image%2020250328133736-4.png)   
## 卫星知识：

￼1.deepseek 机器部署  
**基于 Ollama 的本地化部署**  
**核心步骤**==：==

- ==​==**安装 Ollama**==￼====curl== ==-fsSL== ==https://ollama.com/install.sh== ==| sh====￼====ollama start== _# 启动服务_==￼====ollama -v== _# 验证安装[5,8](@ref)_
- ==​==**下载 DeepSeek 模型**==￼====ollama run deepseek-r1:7b== _# 根据硬件配置选择模型版本（如 1.5B/7B/14B/32B 等）_
- ==显存需求参考：1.5B 需约 1GB，7B 需约 4GB，32B 需约 18GB（需 NVIDIA 显卡支持）==
- ==​==**配置前端界面（可选）****​**
- ==​==**Chatbox AI** ==或== ==​==**Cherry Studio**==：====￼====下载后设置 API 地址为== ==http://localhost:11434====，选择已下载的模型即可交互==    
# 4.快速定位并分析问题

1.rd_test 工具  
shell 脚本实现
 
2.NQA 工具  
java 工具实现
    
# 5.熟练使用git工具

## 1.gerrit 与 hooks

Hooks 是一些在特定事件发生时由 Git 自动触发执行的脚本，  
官方提供的 commit-msg 钩子  
此脚本会根据提交内容生成唯一的 Change-Id  
​**Change-Id** **的作用**：确保代码变更可追踪、避免重复评审。  
Gerrit 是一款基于 Git 的**代码审查工具**，核心功能是强制要求代码在合并到主分支前必须经过人工审核，确保代码质量和团队协作规范  
通过 Gerrit 官方 commit-msg 钩子实现无缝集成，提升团队协作效率。
   

## 2.rebase 多种用法

（1）同步上游分支更新（保持线性历史）  
git checkout feature # 切换到功能分支  
git fetch origin # 获取远程最新代码  
git rebase origin/main # 将功能分支的提交重新应用到主分支最新提交之后
 
效果：  
• 提交历史变为线性（无合并提交），例如原本分叉的历史：
 
A---B---C (main)  
\  
D---E (feature)
 
执行 rebase 后变为：
 
A---B---C (main)  
\  
D'---E' (feature)
 
注意：若同步过程中有冲突，需手动解决后执行 git rebase --continue
   

（2）整理提交历史（交互式变基）  
场景：合并多个零碎提交为完整功能单元，或修改提交信息。  
git rebase -i HEAD~3 # 交互式调整最近3个提交  
1. 在编辑界面中，将前两个提交标记为 squash（合并）：  
pick a1b2c3d Add login form  
squash d4e5f6g Fix typo  
pick h7i8j9k Add validation  
2. 保存后，Git 会将第二个提交合并到第一个提交中，并允许修改最终提交信息。  
结果：3个提交变为2个，历史更简洁。
   

（3）合并分支（替代 git merge）  
场景：将功能分支合并到主分支时，避免产生合并提交。  
git checkout main  
git rebase feature # 将主分支变基到功能分支上（需谨慎）
 
注意：此操作会重写主分支历史，仅适用于个人分支或未推送的公共分支。
   

（4）部分提交迁移（`--onto` 参数）  
场景：将分支中的部分提交应用到其他分支。  
**git** **rebase --onto** 主要分支 次要分支的目标提交的上一个提交 次要分支的目标提交  
（如：git rebase --onto release/xianggang rfw35v456wv sz86d4frw48）
          
# 为什么要跳槽？

1.在原公司中很锻炼技术，学习了很多计算机技术和软件开发流程方面的知识。  
2.希望待遇可以得到提升，希望尝试新的工作方向。
    
java 工作栈
 
### 一、**开发与调试工具**  
1. **集成开发环境（IDE）**  
• **IntelliJ IDEA**：智能代码补全、重构功能强大，支持Spring等主流框架，社区版免费。  
• **Eclipse**：开源免费，插件生态丰富，适合大型项目管理。
 
2. **文本编辑器**  
• **Visual Studio Code**：轻量级编辑器，通过Java扩展包快速适配开发需求。
 
### 二、**构建与依赖管理**  
1. **Maven**  
• 基于XML的标准化构建工具，依赖管理自动化，适合企业级项目。  
2. **Gradle**  
• 灵活配置支持复杂构建流程，构建速度更快，逐渐成为主流选择。
 
---
 
### 三、**测试与性能分析**  
1. **单元测试**  
• **JUnit**：Java测试标准框架，支持参数化测试和断言库。  
• **Mockito**：模拟对象生成工具，简化依赖隔离场景的测试。  
2. **性能分析**  
• **VisualVM**：免费工具，支持内存、线程和CPU分析。  
• **JProfiler**：商业工具，提供深度性能优化建议。
 
---
 
### 四、**版本控制与协作**  
• **Git**：分布式版本控制系统，支持分支管理和团队协作。  
• **GitHub/GitLab**：代码托管平台，集成CI/CD流程。
 
---
 
### 五、**持续集成与部署**  
• **Jenkins**：自动化构建、测试和部署工具，支持CI/CD流水线。  
• **Docker**：容器化部署，确保环境一致性。
 
---
 
### 六、**其他常用工具**  
• **飞算JavaAI开发助手**：全程智能引导需求分析、代码生成与优化，提升开发效率。  
• **Log4j/SLF4J**：日志记录工具，方便调试和问题排查。
 
---
 
### 工具选择建议  
• **企业级开发**：IntelliJ IDEA + Maven + Spring + DataGrip。  
• **轻量级项目**：VS Code + Gradle + JUnit。  
• **微服务架构**：Spring Cloud/Dubbo + Docker + Jenkins。
 
---
 
以上工具覆盖了Java开发的全流程，开发者可根据项目需求、团队规模和技术栈灵活选择。建议从基础工具（如IDE、Maven）入手，逐步扩展至测试、性能优化和框架集成。
 
## 1.已经授权的专利详情

该技术提出一种动态多层密钥管理体系，通过分层嵌套加密（不同层级使用不同算法）和实时性能监控，实现密钥系统的自适应优化与安全防护。核心特点包括：
 
**场景**：云存储服务的数据加密
             
# 履历：
 
## 1.内建函数开发
         

## 2.伪表技术开发
   

## 卫星知识：

### 1.数据库整体架构

数据库的整体架构通常分为多个层次和模块，各司其职以高效管理数据。以下是其核心组成部分的简要概述：
   

### 2.sql 在数据库中执行流程

**一、客户端请求阶段**
 
**1. 解析阶段（Parser）**
 
**2. 查询优化阶段（Optimizer）**
 
**3. 执行计划生成（Execution Plan Generation）**
          
### 3.sql 语句的使用
       
### 4.数据库核心组件
 
**Server****层**是数据库的“逻辑处理核心”，负责SQL解析、优化与执行，包含以下核心组件：
 
**存储引擎层**负责数据存储与检索，支持插件式架构（如InnoDB、MyISAM）。以InnoDB为例，其核心组件包括：
 
**四、其他关键模块**
                
# 二.数据库外部接口开发

## 1.java 数据库接口开发
   

## 卫星知识：
   

**一、关系与历史背景**
 
**二、共同点**
   

**四、典型应用场景**
 
**五、如何选择？**
          
# 三.多平台机器支持与项目适配
   

## 卫星知识：
    
# 4.快速定位并分析问题
      

# 5.熟练使用git工具

## 1.gerrit 与 hooks
   

## 2.rebase 多种用法
                            
# 为什么要跳槽？