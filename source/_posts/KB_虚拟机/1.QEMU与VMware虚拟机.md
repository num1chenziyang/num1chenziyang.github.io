---
title: 1.QEMU与VMware虚拟机
date: 2025-04-09 22:49:54
categories:
  - KB虚拟机
tags: 
password:
---
# （一）QEMU、KVM、VMware 的架构解析与协作机制
## 一、核心架构与设计理念
1. **QEMU**  
   - **架构类型**：用户态全系统模拟器 + 虚拟化协调器（配合KVM等加速器）。  
   - **核心组件**：  
     - **动态二进制翻译（TCG）**：将虚拟机指令转换为宿主机指令（纯软件模拟）。  
     - **设备模型**：模拟网卡、磁盘、GPU等硬件（如e1000、virtio设备）。  
     - **加速器接口**：支持KVM、Hyper-V、WHPX（Windows Hypervisor Platform）等后端。  
   - **运行模式**：  
     - **纯模拟模式**：完全通过软件模拟硬件（性能低，可跨架构运行）。  
     - **硬件加速模式**：依赖KVM/Hyper-V接管CPU和内存（性能接近原生）。  

2. **KVM**  
   - **架构类型**：Linux内核模块（Type-2 Hypervisor组件）。  
   - **核心组件**：  
     - **CPU虚拟化**：利用Intel VT-x/AMD-V指令扩展，直接在物理CPU上运行虚拟机内核态代码。  
     - **内存虚拟化**：通过EPT（Intel）/NPT（AMD）实现二级地址转换，减少内存访问开销。  
     - **中断虚拟化**：注入虚拟中断到虚拟机，处理APIC虚拟化。  
   - **依赖关系**：  
     - 必须运行在支持硬件虚拟化的CPU上，且需要用户态工具（如QEMU）处理I/O。  

3. **VMware**  
   - **架构类型**：  
     - **Type-2 Hypervisor**（Workstation/Fusion）：运行在宿主OS之上，通过内核驱动（如vmmon）访问硬件。  
     - **Type-1 Hypervisor**（ESXi）：直接运行在裸机，接管所有硬件资源。  
   - **核心组件**：  
     - **VMkernel**（ESXi）：轻量级内核，直接管理CPU、内存、存储和网络。  
     - **虚拟设备驱动**：优化后的虚拟SCSI控制器（pvSCSI）、网络适配器（vmxnet3）。  
     - **管理工具链**：vSphere（ESXi集群管理）、VMware Tools（增强性能与集成功能）。  


## 二、QEMU与KVM的协作架构（Linux环境）
### 1. 架构分层
```plaintext
   +-----------------------+
   |     虚拟机 Guest OS    |
   +-----------------------+
   |  虚拟硬件层（QEMU模拟）  | ← 由QEMU模拟网卡、磁盘等设备
   +-----------------------+
   |  KVM内核模块（CPU/内存） | ← 处理CPU指令和内存映射
   +-----------------------+
   |     Linux内核/Hardware | ← 物理硬件
   +-----------------------+
```

### 2. 详细协作流程
   - **步骤1：QEMU初始化**  
     - QEMU通过`-accel kvm`参数启用KVM加速。  
     - 调用`/dev/kvm`接口创建虚拟机（VM）和虚拟CPU（vCPU）。  
   - **步骤2：KVM接管CPU与内存**  
     - KVM通过`ioctl(KVM_RUN)`将vCPU绑定到物理CPU核心，利用VT-x进入“非根模式”运行虚拟机代码。  
     - 内存通过EPT映射到虚拟机，由硬件直接处理地址转换。  
   - **步骤3：I/O设备模拟**  
     - 虚拟机访问模拟设备（如磁盘写入）时，触发VM-Exit，控制权回到KVM。  
     - KVM将I/O请求转发给QEMU的用户态进程，由QEMU处理设备模拟（如写入镜像文件）。  
   - **步骤4：中断与事件处理**  
     - QEMU通过`eventfd`和`irqfd`机制向KVM注入虚拟中断，减少上下文切换。  

### 3. 性能优化技术
   - **Virtio半虚拟化**：虚拟机使用virtio驱动直接与QEMU通信，减少模拟开销。  
   - **巨页（Huge Pages）**：KVM使用大内存页减少TLB缺失。  
   - **vCPU绑定**：将vCPU固定到物理CPU核心，避免调度抖动。  


## 三、VMware的架构实现
1. **Type-2 Hypervisor（Workstation）**  
   ```plaintext
   +-------------------------+
   |     虚拟机 Guest OS      |
   +-------------------------+
   |  虚拟硬件层（vmxnet3等  ） | ← VMware优化的虚拟设备
   +-------------------------+
   |   VMware虚拟化层（vmmon） | ← 内核驱动直接访问硬件
   +-------------------------+
   |  宿主OS（Windows/Linux） | ← 依赖宿主OS的调度和资源管理
   +-------------------------+
   |        物理硬件          |
   +-------------------------+
   ```
   - **特点**：  
     - 设备模拟代码运行在用户态，通过宿主OS内核驱动（如vmmon、vmci）访问硬件。  
     - 支持Unity模式：将虚拟机应用窗口集成到宿主桌面。  

2. **Type-1 Hypervisor（ESXi）**  
   ```plaintext
   +-----------------------+
   |     虚拟机 Guest OS    |
   +-----------------------+
   |  虚拟硬件层（VMkernel） | ← 直接管理硬件资源
   +-----------------------+
   |        物理硬件        |
   +-----------------------+
   ```
   - **特点**：  
     - VMkernel直接控制硬件，无需宿主OS，减少性能损耗。  
     - 支持高级功能：vMotion（热迁移）、DRS（动态资源调度）。  


## 四、跨平台支持与性能对比
| **特性**         | **QEMU+KVM（Linux）**        | **QEMU+WHPX（Windows）**    | **VMware Workstation**      | **VMware ESXi**          |
|------------------|-----------------------------|----------------------------|----------------------------|--------------------------|
| **虚拟化类型**    | 硬件加速（KVM）              | 硬件加速（WHPX）            | 硬件加速 + 软件模拟         | 硬件加速（裸机Hypervisor） |
| **CPU性能**      | 接近原生（<5%损耗）          | 较高损耗（10-20%）          | 低损耗（5-10%）             | 接近原生（<3%损耗）        |
| **I/O性能**      | 依赖virtio（需驱动优化）      | 较低（依赖Windows驱动）      | 高（优化驱动如vmxnet3）      | 最高（VMkernel直接控制）   |
| **跨平台支持**    | 仅Linux宿主                 | Windows/Linux（QEMU跨平台） | Windows/Linux宿主           | 独立部署（无宿主OS）       |
| **硬件依赖**      | 必须启用VT-x/AMD-V          | 需要支持WHPX的CPU           | 需要VT-x/AMD-V             | 需要VT-x/AMD-V           |


## 五、关键架构差异总结
1. **QEMU**  
   - **优势**：灵活支持多架构（x86、ARM、RISC-V），可脱离KVM独立运行。  
   - **劣势**：纯模拟模式性能差，依赖外部组件（如KVM）实现高性能。  

2. **VMware**  
   - **优势**：商业级优化（如内存去重、快照管理），开箱即用。  
   - **劣势**：闭源，ESXi需要专用硬件支持。  


## 六、典型场景与选择建议
- **开发/测试多架构系统** → QEMU纯模拟模式（无需KVM）。  
- **Linux服务器虚拟化** → QEMU+KVM（开源高性能）。  
- **企业级虚拟化集群** → VMware ESXi（高可用性+高级管理功能）。  
- **跨宿主OS桌面虚拟化** → VMware Workstation或QEMU+WHPX（Windows）。  

---

# （二）两者对ARM架构的支持情况
## 一、QEMU+KVM 在 ARM 架构上的支持
#### **1. 是否可用？**
• **QEMU**：完全支持 ARM 架构。  
  • 可以模拟 ARM 设备（如树莓派、ARM 服务器），甚至支持 **跨架构模拟**（如在 x86 主机上运行 ARM 虚拟机）。  
  • 纯软件模拟模式下性能较低，但适合开发和测试。
• **KVM**：在 ARMv8 及更高版本上支持硬件虚拟化。  
  • 需要 **ARM 处理器支持虚拟化扩展**（如 ARM Cortex-A72/A76 及以上，或服务器级 CPU 如 Neoverse）。  
  • 通过 **KVM/ARM** 模块实现，需 Linux 内核支持（内核版本 ≥ 4.4）。  
  • 结合 QEMU 后（即 **QEMU-KVM**），可提供接近物理机的性能。

#### **2. 典型应用场景**
• **ARM 服务器虚拟化**：在支持 KVM 的 ARM 服务器（如 AWS Graviton、Ampere Altra）上运行虚拟机。  
• **嵌入式开发**：模拟树莓派设备，调试嵌入式系统。  
• **跨架构开发**：在 x86 主机上运行 ARM 虚拟机（需纯 QEMU 模拟，无 KVM 加速）。

#### **3. 优点**
• **开源免费**：无需付费，适合个人和企业低成本部署。  
• **灵活性高**：支持多种 ARM 设备和跨架构模拟。  
• **性能优秀**：在支持 KVM 的硬件上，性能接近物理机。

#### **4. 缺点**
• **配置复杂**：需手动管理虚拟化环境和设备模拟。  
• **生态工具较少**：缺乏企业级管理平台（需自行集成 OpenStack 等工具）。


## 二、VMware 在 ARM 架构上的支持
#### **1. 是否可用？**
• **VMware Workstation/ESXi**：**不支持 ARM 架构**。  
  • VMware 主要针对 x86 生态，其桌面级（Workstation）和服务器级（ESXi）虚拟化产品均未提供 ARM 版本。  
• **VMware Fusion（macOS 版）**：仅支持在 Apple Silicon（ARM）上运行 x86 虚拟机（通过 Rosetta 2 转译），**无法原生运行 ARM 虚拟机**。  
• **VM的 ARM 探索**：  
  • VMware 曾宣布与 ARM 合作（如 2018 年推出的 ESXi on ARM 技术预览版），但 **未推出成熟的商用产品**。  
  • 目前 **无官方支持的 ARM 虚拟化解决方案**。

#### **2. 替代方案**
• **AWS 等云服务商**：在 ARM 服务器（如 AWS Graviton）上提供基于 KVM 的虚拟机，但由云平台底层管理，用户无法直接使用 VMware。


### 三、QEMVM vs. VMware

| **场景**               | **QEMU+KVM**                                      | **VMware**                                   |
|------------------------|--------------------------------------------------|---------------------------------------------|
| **ARM 原生虚拟化**      | ✅ 唯一选择（需硬件支持 KVM）                     | ❌ 无可用产品                               |
| **跨架构模拟（x86→ARM）**| ✅ 支持（纯 QEMU 模拟）                           | ❌ 不支持                                   |
| **性能**               | ⭐⭐⭐⭐（KVM 加速下）                               | ❌ 无 ARM 版本                              |
| **管理工具**           | 需手动配置或集成开源工具（如 Libvirt）           | ❌ 无 ARM 版本                              |
| **成本**               | 免费                                             | ❌ 无 ARM 版本                              |


## 四、使用建议
#### **1. 选择 QEMU+KVM 的情况**
• 在 **ARM 服务器或开发板**（如树莓派 4、NVIDIA Jetson）上运行虚拟机。  
• 需要 **原生 ARM 虚拟化** 或 **跨架构模拟**。  
• 预算有限，依赖开源生态。

#### **2. 放弃 VMware 的情况**
• VMware **无 ARM 版本**，若需商业级虚拟化工具，需转向其他方案：  
  • **云服务**：直接使用 AWS Graviton 实例（底层基于 KVM）。  
  • **容器化**：使用 Docker 或 Kubernetes 替代虚拟机（轻量级隔离）。

#### **3. 性能优化建议**
• 确保 ARM 硬件支持虚拟化扩展（如 `/proc/cpuinfo` 显示 `ID_AA64MMFR1_EL1` 包含 `VMID`）。  
• 使用最新 Linux 内核和 QEMU 版本（如 QEMU 7.0+）。  
• 为虚拟机分配足够的 CPU 核和内存，避免过度模拟设备。

---

# （三）QEMU 在 ​aarch64上运行​arm32的虚拟机
是的，QEMU 可以在 **aarch64（ARM64）** 主机上运行 **arm32（ARM32）** 的虚拟机，但需注意以下关键点：
### **一、实现条件**
1. **QEMU 版本支持**：
   • QEMU 需包含 `qemu-system-arm` 组件（用于运行 ARM32 系统级虚拟机）。
   • 检查是否安装：
     ```bash
     qemu-system-arm --version
     ```
   • 若未安装，通过包管理器安装：
     ```bash
     sudo apt install qemu-system-arm  # Debian/Ubuntu
     ```

2. **主机 CPU 兼容性**：
   • aarch64 处理器需支持 **AArch32 执行状态**（即兼容 32 位指令）。
   • 大多数 ARMv8+ CPU 支持（如 Cortex-A53/A72），但部分新架构可能已移除 AArch32 支持（如 Apple M1/M2 的 CPU 不支持）。

3. **镜像要求**：
   • 需使用 **ARM32 操作系统镜像**（如 Debian armhf、Raspbian）。


### **二、操作步骤**
#### **1. 下载 ARM32 镜像**
以 Debian armhf 为例：
```bash
wget https://cdimage.debian.org/cdimage/archive/11.7.0-live/armhf/iso-hybrid/debian-live-11.7.0-armhf-standard.iso
```

#### **2. 创建虚拟磁盘**
```bash
qemu-img create -f qcow2 arm32_disk.qcow2 8G
```

#### **3. 启动 ARM32 虚拟机**
```bash
qemu-system-arm \
  -M virt \          # 使用通用 ARM 虚拟设备模型（需内核支持）
  -cpu cortex-a15 \  # 模拟 32 位 ARM CPU（需与镜像兼容）
  -smp 2 \           # 分配 2 个 CPU 核心
  -m 2G \            # 分配 2GB 内存
  -drive file=arm32_disk.qcow2,format=qcow2 \  # 挂载虚拟磁盘
  -kernel /path/to/vmlinuz \        # 手动指定内核（可选）
  -initrd /path/to/initrd.img \     # 手动指定 initrd（可选）
  -append "root=/dev/sda2 console=ttyAMA0" \  # 内核启动参数
  -nographic \        # 禁用图形界面（仅终端）
  -device virtio-net-pci,netdev=net0 \  # 网络设备
  -netdev user,id=net0,hostfwd=tcp::2222-:22  # 端口转发（SSH）
```

#### **4. 安装系统**
• 如果是 Live 镜像，启动后可按提示安装到虚拟磁盘。


### **三、注意事项**
#### **1. 性能问题**
• **无硬件加速**：ARM64 主机上运行 ARM32 虚拟机时，QEMU 默认使用 **TCG（软件模拟）**，性能较低。
• **无法使用 KVM**：KVM 要求虚拟机与主机架构相同（ARM64→ARM64 或 ARM32→ARM32），跨位宽（32↔64）无法加速。

#### **2. 镜像兼容性**
• **内核适配**：部分 ARM32 镜像可能需要手动指定内核（`-kernel` 和 `-initrd`），否则可能因默认内核不兼容导致启动失败。
• **设备驱动**：需确保镜像包含 `virtio` 驱动（如磁盘、网卡）。

#### **3. 图形界面支持**
• 若需图形界面，移除 `-nographic` 并添加：
  ```bash
  -vga virtio \        # 使用虚拟显卡
  -display gtk         # 启用 GUI 窗口
  ```


### **四、常见问题**
#### **1. 启动时卡住或无输出**
• **原因**：内核或启动参数不兼容。
• **解决**：手动指定内核和 initrd：
  ```bash
  -kernel vmlinuz-3.10.0-957.el7.armv7hl \
  -initrd initramfs-3.10.0-957.el7.armv7hl.img
  ```

#### **2. 网络无法连接**
• **原因**：未正确配置网络设备或防火墙。
• **解决**：使用用户模式网络并检查端口转发：
  ```bash
  -netdev user,id=net0,hostfwd=tcp::2222-:22
  ```


### **五、替代方案**
#### **1. 使用 Docker 运行 32 位 ARM 程序**
如果仅需运行单个 ARM32 应用（非完整系统）：
```bash
docker run --rm -it arm32v7/debian bash
```

#### **2. 使用 Raspberry Pi 镜像**
模拟树莓派等特定设备：
```bash
qemu-system-arm \
  -M raspi2b \        # 树莓派 2型号
  -kernel kernel7.img \  # 树莓派内核
  -sd raspbian.img    # 树莓派系统镜像
```

---

# （四）虚拟化技术栈
## 一、虚拟化技术栈的分层架构
虚拟化工具遵循 **分层设计**，各层分工明确，协同工作。整体架构可分为以下四层：
```
+-----------------------------------+
|         **用户工具层**             |  ← virt-manager、virsh、virt-install
+-----------------------------------+
|         **管理层 (libvirt)**      |  ← 统一抽象接口、资源调度、生命周期管理
+-----------------------------------+
|    **Hypervisor 层 (QEMU/KVM)**   |  ← 硬件虚拟化实现
+-----------------------------------+
|        **Host 操作系统层**         |  ← Linux 内核、硬件驱动
+-----------------------------------+
```


## 二、各层组件功能详解
#### **1. Host 操作系统层（底层）**
• **功能**：
  • 提供物理硬件（CPU、内存、存储、网络）的基础支持。
  • 运行 Linux 内核（或其他支持虚拟化的操作系统），加载 KVM 内核模块。
• **关键组件**：
  • **KVM 内核模块**：实现 CPU 和内存的硬件虚拟化（依赖 Intel VT-x/AMD-V）。
  • **QEMU 用户态程序**：模拟 I/O 设备（磁盘、网卡、显卡等）。

#### **2. Hypervisor 层（QEMU/KVM）**
• **功能**：
  • **QEMU**：作为 Type-2 Hypervisor（宿主机型虚拟化），通过软件模拟硬件设备。
  • **KVM**：提供硬件加速，将虚拟机指令直接 CPU 执行。
  • **协作模式**：  
    ◦ QEMU 调用 KVM 接口实现 CPU/内存虚拟化，自身处理设备模拟。
    ◦ 组合为 **QEMU-KVM**，兼顾性能与灵活性。
• **核心操作**：
  ```bash
  # 直接调用 QEMU 启动虚拟机（无管理层介入）
  qemu-system-x86_64 -enable-kvm -m 4G -hda vm.img
  ```

#### **3. 管理层（libvirt）**
• **功能**：
  • **统一抽象接口**：标准化不同虚拟化技术（KVM、Xen、LXC、VMware等）的管理操作。
  • **生命周期管理**：创建、启动、暂停、迁移、销毁虚拟机。
  • **资源调度**：管理虚拟网络、存储池、设备绑定等。
  • **安全策略**：通过 SELinux、AppArmor 实现隔离和权限控制。
• **核心组件**：
  • **libvirt API**：提供 C、Python 等语言的编程接口。
  • **libvirtd 守护进程**：运行在宿主机上，响应客户端（如 virsh、virt-manager）的请求。
  • **XML 配置**：以 XML 文件定义虚拟机硬件规格（CPU、内存、磁盘、网络等）。
• **数据流示例**：
  ```
  virt-manager → libvirt API → libvirtd → QEMU-KVM
  ```

#### **4. 用户工具层**
• **功能**：
  • 提供用户友好的接口，通过 libvirt 间接管理 Hypervisor。
  • 支持命令行（CLI）和图形界面（GUI）两种交互方式。
• **核心工具**：
  • **virsh（CLI）**：  
    ◦ 通过命令直接操作 libvirt，适合自动化脚本和服务器环境。
    ◦ **常用命令**：
```bash
    virsh list --all           # 列出所有虚拟机
    virsh start/reboot/shutdown <vm>  # 管理虚拟机状态
    virsh edit <vm>            # 编辑虚拟机 XML 配置
    virsh net-list             # 管理虚拟网络
```
  • **virt-manager（GUI）**：  
    ◦ 图形化界面，提供虚拟机创建、监控、实时迁移等功能。
    ◦ **核心功能**：
      ◦ 可视化配置虚拟机硬件（CPU 拓扑、磁盘格式、虚拟网络）。
      ◦ 实时监控资源使用（CPU、内存、磁盘 I/O）。
      ◦ 通过 VNC/SPICE 连接虚拟机控制台。
  • **virt-install（CLI）**：  
    ◦ 快速创建虚拟机，避免手动编辑 XML。
    ◦ **示例**：
```bash
    virt-install --name=centos \
        --memory=2048 --vcpus=2 \
        --disk path=/var/lib/libvirtcentos.qcow2,size=20 \
        --os-type=linux --os-variant=centos7 \
        --network network=default \
        --cdrom=/path/to/centos.iso
```
  • **辅助工具**：
    ◦ **virt-viewer**：连接虚拟机图形控制台（基于 SPICE/VNC）。
    ◦ **virt-v2v**：将物理机或其他虚拟化平台的系统迁移到 libvirt 环境。
    ◦ **virt-top**：监控虚拟机资源使用（类似 top 命令）。


## 三、工具间的协作关系
#### **1. 创建虚拟机的典型流程**
1. **用户通过 virt-manager 点击“新建虚拟机”**：
   • virt-manager 调用 libvirt API，生成虚拟机 XML 配置模板。
2. **libvirtd 接收请求**：
   • 验证权限，创建虚拟磁盘文件，生成最终 XML 配置。
3. **libvirtd 调用 QEMU-KVM**：
   • 根据 XML 启动 `qemu-system-x86_64` 进程，传入参数（如 `-enable-kvm -m 4G`）。
4. **QEMU-KVM 加载镜像**：
   • 模拟硬件，启动 Guest OS。

#### **2. 虚拟机状态管理**
• **virsh 命令** → **libvirtd** → **QEMU 进程信号**：
  • `virsh shutdown` → 发送 ACPI 关机信号给 Guest OS。
  • `virsh destroy` → 强制终止 QEMU 进程（类似断电）。

#### **3. 跨主机迁移**
• **virsh migrate **libvirtd（源主机）** → **libvirtd（目标主机）**：
  • 通过 TCP 传输虚拟机内存和磁盘状态，实现热迁移。


## 四、工具选型与适用场景

| **工具**           | **适用场景**                          | **优势**                |
| ---------------- | --------------------------------- | --------------------- |
| **virsh**        | 服务器环境、自动化脚本、批量操作（如 Ansible 集成）。   | 轻量级、无依赖、适合 DevOps 流程。 |
| **virt-manager** | 桌面环境、可视化操作、调试虚拟机硬件配置。             | 直观、易用、支持实时监控。         |
| **virt-install** | 快速创建标准化虚拟机（如云镜像模板）。               | 避免手动编辑 XML，提升效率。      |
| **libvirt API**  | 开发自定义管理平台（如 OpenStack Nova 底层调用）。 | 跨平台、标准化、可扩展性强。        |


## 五、安全与权限管理
• **用户权限**：
  • 普通用户需加入 `libvirt` 组才能操作虚拟机：
```bash
sudo usermod -aG libvirt $USER
```
• **SELinux/AppArmor**：
  • 限制虚拟机进程的访问权限（如隔离磁盘和网络资源）。
• **虚拟网络隔离**：
  • 使用 libvirt 的 NAT 或桥接网络，避免虚拟机直接暴露在物理网络。


## 六、总结
• **分层架构**：  
    • **Hypervisor 层**（QEMU/KVM）负责硬件虚拟化执行。  
    • **管理层**（libvirt）提供统一抽象接口和资源调度。  
    • **用户工具层**（virsh/virt-manager）简化操作复杂度。  
• **协作逻辑**：  
       用户工具通过 libvirt API 与 Hypervisor 交互，实现资源的全生命周期管理。  
• **专业场景**：  
    • **开发/测试**：使用 virt-manager 快速搭建环境。  
    • **生产环境**：通过 virsh 和 libvirt API 实现自动化运维。  
    • **混合云**：结合 libvirt 支持的多 Hypervisor 技术构建异构虚拟化平台。

---

# （五）虚拟机搭建
## 一.qemu 虚拟机
直接用 qemu 命令搭建很麻烦，用 virt-manager 可视化搭建方便。
https://cloud.tencent.com/developer/article/1039421


## 二.vmware 虚拟机
https://blog.csdn.net/Alex_thomas/article/details/118832502

---
