inline 是 C 和 C++ 中的一个关键字，用于**提示编译器**将函数定义内联化。内联函数的主要目的是在调用处直接插入函数代码，避免函数调用的开销，提高程序的性能。  
**基本概念：**

- **内联函数**是编译器通过将函数体代码直接插入到函数调用点来减少函数调用的开销，特别是在频繁调用的小型函数时，内联函数可以消除函数调用时的压栈、跳转和返回操作。
- 使用 inline 关键字声明的函数，被**建议**作为内联函数，但这只是一个提示，最终是否内联是由编译器决定的。编译器可能会忽略 inline，尤其当函数过于复杂或者过大时。

**使用方式：**
 
inline int add(int a, int b) {￼ return a + b;￼}￼  
在上面的例子中，add 函数被声明为内联函数。如果编译器决定内联它，那么每次调用 add 时，编译器会将其展开为 a + b，而不是生成一个函数调用。  
**内联函数的好处：**

1. **减少函数调用开销**：
    
    - 常规函数调用需要压栈、跳转到函数地址、执行返回操作等，开销较大。
    - 对小函数使用内联可以直接将函数代码嵌入到调用点，省去了这些调用开销。
2. **优化执行速度**：
    
    - 对于简单、频繁调用的函数（如数学运算、简单的逻辑判断等），内联函数可以提高性能，减少时间消耗。
3. **有助于编译器的进一步优化**：
    
    - 内联函数让编译器有更多的机会进行代码优化，因为展开的函数体可能与周围的代码产生优化空间，如消除多余的操作。

**内联函数的限制和注意事项：**

1. **编译器决定是否内联**： 即使你标记了函数为 inline，编译器也可能不会实际进行内联，特别是在以下情况下：
    
    - 函数体较大或过于复杂。
    - 函数包含递归调用。
    - 函数有不可忽略的副作用，编译器可能出于优化考虑不进行内联。
2. **代码膨胀**： 内联函数会将函数代码插入到每个调用点，这可能导致可执行文件体积膨胀，尤其是当函数非常大且被频繁调用时。大量的内联展开会导致编译出的代码占用更多的内存。
3. **递归函数通常不能内联**： 对于递归函数，内联是无意义的，因为函数会不断调用自己，编译器一般不会尝试将递归函数内联化。
4. **调试**： 内联函数可能使得调试变得复杂，因为在内联过程中，函数调用被展开到调用点，调试时很难直接跟踪到函数调用。

**示例：**
 
#include <stdio.h>￼  
inline int square(int x) {￼ return x * x;￼}￼  
int main() {￼ int a = 5;￼ printf("Square of %d is %d\n", a, square(a));￼ return 0;￼}￼  
如果编译器决定内联 square 函数，那么 square(a) 将会被展开为 a * a，而不会执行实际的函数调用。这可以加快程序的执行速度。  
**结论：**  
inline 是一个优化提示，用于将小而简单的函数直接插入到调用点，从而减少函数调用的开销。但最终是否内联完全由编译器决定。尽量将内联函数用于体积小、逻辑简单且频繁调用的函数，以避免代码膨胀的风险。