---
title: （实战）1.导入导出工具开发
date: 2025-04-21 15:12:02
categories:
  - SDLC功能开发
tags: 
password: 9761565829chen
---
# （前言）esqlc
ESQL/C（Embedded SQL in C）是由 ​**​INFORMIX 公司​**​ 开发的数据库应用开发工具，主要用于将 SQL 语句直接嵌入到 C 语言程序中，实现对数据库的高效访问和操作。随着 INFORMIX 被 IBM 收购，ESQL/C 后续由 ​**​IBM​**​ 维护和升级，成为 Informix 数据库生态的重要组成部分

ESQL/C 旨在解决传统 SQL 的非过程化特性与 C 语言过程化编程之间的矛盾，通过以下方式实现两者的结合：
```shell
- ​嵌入式 SQL 支持​：在 C 代码中直接编写 SQL 语句，如 EXEC SQL SELECT ...，简化数据库操作流程。
- ​预编译技术​​：通过 esql 或 esqlpc 预处理器将 SQL 语句转换为 C 函数调用（如生成 sybesql.c），再编译为可执行程序。
```

对于工具而言，其主要文件是 ec，esqlc 将 ec 解释为 c 文件以供执行。以下为ESQL/C（Embedded SQL in C）中SQL语句预处理、绑定、游标操作的全套流程详解，结合标准流程与实践案例进行说明。

## 一、ESQL/C基础环境配置
### 1. 预处理器与编译流程
ESQL/C通过预处理器将嵌入的SQL代码转换为纯C代码，再通过C编译器生成可执行文件。典型编译流程为：
```bash
esqlc -o demo.c demo.pc  # 将.pc文件预处理为.c文件
gcc -o demo demo.c -I$ORACLE_HOME/precomp/public -L$ORACLE_HOME/lib -lclntsh  # 链接Oracle客户端库
```


## 二、SQL语句预处理与绑定流程
### 1. 声明宿主变量（Host Variables）
在C代码中声明与数据库交互的变量：
```c
EXEC SQL BEGIN DECLARE SECTION;  // 宿主变量声明区开始
    int    emp_id;               // 员工ID
    char   emp_name[50];         // 员工姓名
    double salary;               // 工资
EXEC SQL END DECLARE SECTION;    // 宿主变量声明区结束
```

### 2. 准备SQL语句（PREPARE）
动态SQL语句预编译，支持参数占位符：
```c
EXEC SQL PREPARE emp_query FROM "SELECT ename, sal FROM emp WHERE empno = :id";  
// :id为占位符，后续通过变量绑定赋值
```

### 3. 绑定输入参数（BIND）
将宿主变量与占位符绑定：
```c
EXEC SQL DECLARE emp_cursor CURSOR FOR emp_query;  // 声明游标关联预编译语句
EXEC SQL OPEN emp_cursor USING :emp_id;           // 打开游标并绑定参数
```

### 4. 执行与结果处理
```c
EXEC SQL FETCH emp_cursor INTO :emp_name, :salary;  // 获取结果到宿主变量
while (sqlca.sqlcode == 0) {                        // 循环处理所有结果行
    printf("员工: %s, 工资: %.2f\n", emp_name, salary);
    EXEC SQL FETCH emp_cursor INTO :emp_name, :salary;
}
```

### 5. 关闭资源
```c
EXEC SQL CLOSE emp_cursor;    // 关闭游标
EXEC SQL FREE emp_query;       // 释放预编译语句资源
```


## 三、游标操作详解
### 1. 游标声明与打开
```c
EXEC SQL DECLARE dept_cur CURSOR FOR 
    SELECT deptno, dname FROM dept WHERE loc = 'NEW YORK';  // 静态游标声明
EXEC SQL OPEN dept_cur;                                     // 打开游标
```

### 2. 动态游标与参数化查询
```c
EXEC SQL PREPARE dyn_cur FROM "SELECT * FROM emp WHERE job = ? AND sal > ?";
EXEC SQL DECLARE job_cur CURSOR FOR dyn_cur;  
EXEC SQL OPEN job_cur USING 'MANAGER', 5000;  // 动态绑定多个参数
```

### 3. 游标遍历与异常处理
```c
EXEC SQL WHENEVER NOT FOUND DO break;  // 定义无数据时的行为
while(1) {
    EXEC SQL FETCH dept_cur INTO :deptno, :dname;
    // 处理数据...
}
EXEC SQL WHENEVER SQLERROR CONTINUE;  // 重置错误处理
```

### 4. 敏感性与锁机制
• 敏感游标：声明`SCROLL CURSOR`支持前后滚动（部分DBMS支持）
• 锁控制：添加`FOR UPDATE`子句锁定选中行（需在事务中）
```c
EXEC SQL DECLARE upd_cur SCROLL CURSOR FOR 
    SELECT * FROM accounts WHERE balance < 0 FOR UPDATE;
```


## 四、完整示例：带事务的薪资更新
```c
#include <stdio.h>
EXEC SQL INCLUDE SQLCA;  // 包含SQL通信区

int main() {
    EXEC SQL BEGIN DECLARE SECTION;
        int    dept_no = 10;
        double raise = 500;
    EXEC SQL END DECLARE SECTION;

    EXEC SQL CONNECT TO hr USER scott IDENTIFIED BY tiger;  // 连接数据库

    EXEC SQL PREPARE sal_update FROM 
        "UPDATE emp SET sal = sal + ? WHERE deptno = ?";    // 预编译更新语句
    EXEC SQL DECLARE update_cur CURSOR FOR sal_update;
    
    EXEC SQL BEGIN TRANSACTION;  // 开启事务
    EXEC SQL OPEN update_cur USING :raise, :dept_no;          // 绑定参数并执行
    EXEC SQL CLOSE update_cur;

    if (sqlca.sqlcode == 0) {
        EXEC SQL COMMIT;        // 提交事务
        printf("更新成功，影响行数: %d\n", sqlca.sqlerrd[2]);
    } else {
        EXEC SQL ROLLBACK;      // 回滚事务
        printf("错误代码: %d\n", sqlca.sqlcode);
    }

    EXEC SQL DISCONNECT;        // 断开连接
    return 0;
}
```


## 五、关键注意事项
### 1. 错误处理  
   使用`WHENEVER`指令全局定义错误处理逻辑：
   ```c
   EXEC SQL WHENEVER SQLERROR GOTO error_handler;  // 错误跳转
   ```

### 2. 性能优化  
   • 批量绑定：通过`BULK`子句批量操作（Oracle特有）
   • 参数复用：对高频查询保持预编译语句常驻内存


### 3. 安全实践  
   • 输入校验：对绑定变量内容进行过滤（如防SQL注入）
   • 资源释放：务必关闭游标与释放预处理语句

---

# 一、dbload调研
## 1.快速找到堆栈
```shell
##数据库：
##想断到工具insert与数据库交互处：
gdbi
b ins2cb
c

##工具：
gdb dbimport
set args d1
r
bt

##工具加了新参数的话记得往 help 里加
```


## 2.问题描述
```text
1.导入工具效率低。
2.gci 使用 put 协议优化后效率很高。
3.想要使用 put 协议提高导入数据的效率。
```


## 3.调研过程

| 堆栈        | 文件        |
| --------- | --------- |
| putsqlvar | ldload.ec |
| loaddrow  | ldload.ec |
| infx_load | ldload.ec |
| main      | ldmain.ec |
主要堆栈如上：

| 流程      | note                                                                                                 |
| ------- | ---------------------------------------------------------------------------------------------------- |
| 1.起事务   | $begin work;                                                                                         |
| 2.做语句   | 通过 prepare，bind 等操作，将 insert 语句做好。                                                                   |
| 3.做结构   | 把供 put 使用的结构 ldescptr 做好<br>（此结构包含 insert 语句信息，还有一个 next（暂时没看到地儿用））。                                 |
| 4.put逻辑 | 根据行数（nflds）：<br>做好一个 ldescptr ，put 一次；<br>做好一个 ldescptr ，put 一次；<br>做好一个 ldescptr ，put 一次；<br>...... |
| 5.提事务   | $commit work;<br>此时在数据库中 select 会看到新插入的数据。                                                           |
dbload 在插入数据时，流程如上（这里看到 dbload 用的就是 put 协议）：

| 流程      | note                                                                                  |
| ------- | ------------------------------------------------------------------------------------- |
| 1.二维数组  | 1.通过 prepare，bind 等操作，将 insert 语句做好。<br>2.将多条语句存入一个二维数组，偏移量为 MAX。                     |
| 2.put逻辑 | 设置 put 20 次，与数据库交互一次：<br>偏移取下一行，put 一次；<br>偏移取下一行，put 一次；<br>偏移取下一行，put 一次；<br>...... |
| 3.交互    | 将语句传入数据库                                                                              |
 gci 的 put 逻辑流程如上：

```text
分析：
1.关于put逻辑：
  - 首先，dbload在插入数据时，用的就是put协议。其次，在put逻辑上，dbload和gci都是一条insert语句，put一次，并无分别。只不过dbload是put的ldescptr结构，gci则put的是大buffer里的每条sql语句。所以dbload的性能优化方向并不在put协议上。

2.dbload慢在哪？
  - gci 是与数据库交互的，并无事务。gci 之前慢的原因是频繁与数据库交互（火线图能看出，一条 put 交互一次），后 gci 改为存 20 条 insert 语句，put 20 次，与数据库交互一次，以此优化了性能。
  - 之前一直以为 gci 是一次 put 提交了 20 条语句，误以为 put 的提升效率的关键，实则不然，gci 的效率是提升在了与数据库交互次数的减少上。
  - dbload 之所以相较于 gci 而言慢，是因为其有事务，会有日志、锁竞争、并发的多个额外开销，肯定比 gci 要慢。在创库时不 with log 会有一些速度上的提升。

---------

总结：想要使用 put 协议提高导入数据的效率，此方案不可行（用时 1.5 天）。

---------

收获：对 gci 和 dbload 的内部处理有了一定的认识，熟悉了一下 esqlc 的工作方式，上述记录有助于未来进行相关任务开发。

```

---
