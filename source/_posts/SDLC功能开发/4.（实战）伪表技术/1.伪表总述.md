# 一.伪表基本介绍

## 1.什么是 Pseudo Tables？

在数据库系统中，**pseudo tables（伪表）** 通常指的是那些不直接在物理存储上持久化的表。这些表可以用于：

1. **内部元数据管理**：￼如跟踪数据库运行时的信息、事务状态、系统配置等。
2. **虚拟化表功能**：￼提供类似物理表的访问接口，但实际可能由其他数据结构支持。
3. **优化性能**：￼伪表可以绕过某些普通表的存储和索引开销，提升运行效率。
4. **特殊用途**：￼某些伪表可能用于调试、监控、或支持高级功能（如分布式查询）。
   

## 2.操作步骤的分析

在 Informix 中，创建并标识伪表，这些操作可能是为了调整系统对表的处理方式，使其在内部视为伪表而非普通表。

1. **创建表和索引**：
    
    - 初始化一个普通表结构，并为其创建索引。这是伪表的基本骨架。
    - 创建索引可能是为了模拟或支持伪表的查询行为，但它不一定真正用于存储或物理排序。
2. **调整权限**：
    
    - 收回对表的所有权限，确保其他用户无法在创建或初始化期间对其进行操作。
    - 然后赋予最低权限（查询权限），确保伪表只能被访问而不能被修改。
3. **提取元数据到临时表**：
    
    - 将该表的**元数据**（systables、syscolumns 等）复制到临时表中，提供一个安全的修改缓冲区。这避免了直接操作系统表可能引发的不一致或并发问题。
4. **修改 partnum 和 nrows**：
    
    - **修改 partnum**：￼partnum 通常标识表的物理存储位置或分区编号。将其设置为特定值（如 154），可能是为了告诉数据库引擎这不是一个普通表，而是一个伪表。
        
        - 注释中提到的 **“reset partnums”** 表明这是伪表识别的关键步骤。
    - **修改 nrows**：￼伪造一个特定的行数（如 100），可能用于欺骗引擎的优化器或其他系统模块，让其认为这个伪表有固定的行数。
5. **删除原表**：
    
    - 删除原表后，系统表中的元数据仍然保留（因为这些已经被插入到临时表中）。
6. **将临时表数据重新插入系统表**：
    
    - 将伪表的元数据写回 systables 和其他相关系统表，完成对伪表的标识和注册。
    - 此时，数据库引擎会将其视为伪表，而不再尝试为其分配实际的物理存储。
7. **删除临时表**：
    
    - 清理缓冲区，确保环境整洁，不影响其他操作。
 
note：  
1.元数据：数据库元数据就是指定义数据库各类对象结构的数据。元数据储存在系统表中。
   

## 3.为什么要这样设计？

这种设计的核心目标是通过对系统表的直接修改，将普通表伪装成伪表，并让数据库引擎在内部以不同方式处理它。其目的包括：  
**1. 内部识别伪表**

- 重置 partnum 是为了让引擎能够快速区分普通表和伪表，避免引擎尝试分配物理存储。
- 伪表在内部可能有特定用途，例如作为虚拟视图或缓冲区，用于存储引擎内部的临时或元数据。

**2. 提升性能**

- 伪表不需要分配实际存储位置，减少了 I/O 开销。
- 修改 nrows 提供了一个虚假的行数，可能用于帮助查询优化器生成更高效的执行计划。

**3. 系统表结构的一致性**

- 将伪表注册到系统表（如 systables, syscolumns），可以让伪表看起来和普通表一致。这有助于提高兼容性，让其他模块可以透明地访问伪表。

**4. 控制伪表行为**

- 通过调整权限，限制对伪表的操作范围，确保其只能用于特定用途（如只读查询）。
   

## 4.总结

这段操作旨在通过直接修改系统表元数据，将一个普通表转换为伪表。这种设计可能是为了：

1. **标记和区分伪表**；
2. **提供特殊用途的虚拟表功能**；
3. **优化性能，避免分配实际存储**；
4. **增强数据库引擎的灵活性**。

这种方法虽然复杂，但为数据库提供了一个强大的扩展机制，允许引擎以更灵活的方式处理特殊表结构。在日常使用中，这种伪表可能用于监控、优化器调试、分布式系统支持或其他内部功能。
    
# 二.伪表的数据处理

## 1.伪表的数据来源

1. **伪表的数据来源于内存中的结构**：
    
    - 伪表通常直接映射到数据库引擎的内部内存结构（如系统缓存、内存中的数据字典、运行时状态等）。
    - 当用户查询伪表时，数据库引擎会将伪表的查询翻译为对这些内存结构的直接访问，而不是读取磁盘上的存储。
2. **伪表的数据是动态生成的**：
    
    - 对伪表的查询结果通常由引擎的代码实时生成，而不是从固定存储中检索。例如：
        
        - systables 等伪表可能实时读取引擎维护的表和元数据结构。
        - 性能监控伪表（如记录查询统计的伪表）可能实时读取引擎中的性能计数器或统计信息。
3. **伪表依赖特定的代码路径**：
    
    - 每个伪表都可能有特定的实现代码，在伪表被查询时，这些代码会被调用以生成查询结果。
   

## 2.伪表的数据更新方式

1. **实时更新**：
    
    - 伪表的数据更新由引擎的运行状态或操作驱动。例如：
        
        - 如果伪表反映的是当前的事务状态，每当事务发生变化（如提交或回滚），相关的内存结构就会实时更新。
        - 如果伪表记录的是查询执行的统计信息，每次查询运行时，统计信息都会在内存中更新。
2. **内存结构更新**：
    
    - 伪表依赖的内存结构通常由数据库的内部组件主动维护：
        
        - 系统元数据伪表：由数据库的元数据管理模块更新。
        - 性能监控伪表：由性能监控模块更新。
        - 运行时状态伪表：由事务管理器、调度器等模块更新。
3. **触发更新**：
    
    - 某些伪表可能在特定操作或事件时触发更新：
        
        - 插入、更新或删除某个普通表时，伪表的数据可能会反映这些变更。
        - 特定的管理操作（如收缩表空间、更新统计信息）可能触发伪表数据的刷新。
   

## 3.伪表的工作机制

伪表在查询时并不直接访问物理存储，而是遵循以下流程：

1. **SQL 查询解析**：
    
    - 当用户执行查询伪表的 SQL 语句时，SQL 解析器会识别伪表，并将其与普通表区分开来。
2. **特定查询执行计划**：
    
    - 查询引擎会为伪表生成特殊的执行计划，跳过存储层，直接调用内存数据或内部函数。
3. **数据生成或映射**：
    
    - 查询执行时，伪表对应的引擎模块会被调用，通过映射内存结构、计算或读取系统状态，动态生成伪表的返回数据。
   

## 4.举例说明

**示例 1：系统元数据伪表**  
伪表：systables

- 数据来源：数据库的系统数据字典，存储在内存中。
- 数据更新：当用户创建、删除或修改表时，引擎会实时更新数据字典。

查询操作：  
SELECT * FROM systables WHERE tabname = 'my_table';￼  
执行流程：

- SQL 解析器识别 systables 为伪表。
- 查询引擎直接访问内存中的系统数据字典，检索对应信息。
- 返回查询结果。
 
**示例 2：性能监控伪表**  
伪表：sysmon

- 数据来源：引擎的性能统计模块，实时记录 CPU、IO 等指标。
- 数据更新：引擎定期或在相关事件发生时更新性能统计信息。

查询操作：  
SELECT cpu_usage, io_wait FROM sysmon;￼  
执行流程：

- SQL 解析器识别 sysmon 为伪表。
- 查询引擎调用性能监控模块，读取当前的性能计数器值。
- 返回查询结果。
   

## 5.为什么伪表只提供查询权限？

伪表的核心功能是**反映系统状态**，因此它们通常是只读的：

1. **安全性**：￼防止用户误操作或恶意修改伪表内容，导致系统行为异常。
2. **数据来源限制**：￼伪表数据通常是动态生成的，无法支持插入、更新或删除操作。
3. **设计意图**：￼伪表的用途是提供信息，而非存储数据。
 
## 6.总结

伪表的数据来自于数据库引擎的内存结构或实时生成，不占用物理存储空间。  
它们的数据更新是由引擎模块维护的内存结构自动驱动，且在查询时动态生成返回结果。伪表的查询权限是为了保证数据的一致性和安全性，同时强调其只读性质。