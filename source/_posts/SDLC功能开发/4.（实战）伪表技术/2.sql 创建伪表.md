# 一.操作流程概述

**sysmaster.sq****l**

1. **创建表（可以创建索引）**：￼先创建一个表，也可以创建索引。
2. **收回权限并重新赋予查询权限**：￼收回对表的所有权限后，仅赋予查询权限，限制后续的操作范围，确保后续插入的系统表数据不会被误改。
3. **从系统表提取元数据并插入临时表**：￼将目标表的元数据（如列信息、索引、权限、状态、BLOB 信息等）从系统表中提取并存储到临时表中。
4. **修改临时表中的元数据**：￼修改 tempsystab 中 tabid 对应的 partnum 和 nrows 的值，以获取伪表特征。
5. **删除原表并还原系统表中的元数据**：￼删除创建的表后，再将临时表中的数据插入回系统表，完成对系统表的直接更新。
6. **删除临时表**：￼清理临时表，恢复干净的环境。
    
# 二.创建伪表 sql 语句

## 1.将partnum连接到表名

{join for partnums to table names}
 
create table gbasedbt.systabnames  
{  
partnum integer, {table id for table}  
dbsname char(128), {database name}  
owner char(32), {table owner}  
tabname char(128), {table name}  
collate char(32), {collation assoc with database}  
dbsnum intager {dbspace number}  
};  
create unique index gbasedbt.systabs_pnix on systabnames(partnum);  
create index gbasedbt.systabs_pnix2 on systabnames(dbsnum);  
revoke all on gbasedbt.systabnames from public as gbasedbt;  
grant select on gbasedbt.systabnames to public as gbasedbt;
 
create table ......
   

## 2.从目录中获取信息并保存

{get info out of catalogs and save it}
 
select tabid from systables where tabname in ('systabnames','syscdr_ddr','syssmx'**......**) into temp temptabid with no log;  
select * from systables where **tabid** in (select tabid from temptabid) into temp tempsystab with no log;  
select * from syscolumns where **tabid** in (select tabid from temptabid) into temp tempsyscol with no log;  
select * from sysindices where **tabid** in (select tabid from temptabid) into temp tempsysidx with no log;  
select * from systabauth where **tabid** in (select tabid from temptabid) into temp tempsysauth with no log;  
select * from sysobjstate where **tabid** in (select tabid from temptabid) into temp tempsysobj with no log;  
select * from sysblobs where **tabid** in (select tabid from temptabid) into temp tempsysblobs with no log;
   

## 3.重置partnums，在内部便可将其识别为伪表，并在优化器中更新列表

{reset partnums so internally we recognize these as pseudo tables, also update nrows to clue in the optimizer}
 
update tempsystab set (partnum, nrows) = (15, 1000) where tabname = 'systabnames';  
update tempsystab ......  
drop table systabnames;  
--此处删除后 systabnames 表后，systables、syscolumns等系统表关于其的信息也一并删除了  
drop table ......
   

## 4.将修改后的目录信息重新插入目录中

{reinsert modified catalog info into catalogs}
 
insert into systables select from tempsystab;  
insert into syscolumns select from tempsyscol;  
insert into sysindices select from tempsysidx;  
insert into systabauth select from tempsysauth;  
insert into sysobjstate select from tempsysobj;  
insert into sysblobs select from tempsysblobs;  
--此时systabnames的伪表已经做成  
drop table tempsystab;  
drop table tempsyscol;  
drop table tempsysidx;  
drop table tempsysauth;  
drop table tempsysobj;  
drop table tempsysblobs;
 
## note：

1.伪表制作步骤简述：  
（1）temp 将systabnames表存储在systables 、syscolumns 、sysindices 、systabauth 、sysobjstate 、sysblobs 系统表中的信息全部储存了起来（也可以说 temp 存储了systabnames表的元数据）。  
（2）修改partnum与nrows，创立了伪表的标识。  
（3）将systabnames本体删除，其在systables 、syscolumns 、sysindices 、systabauth 、sysobjstate 、sysblobs 系统表中的信息被清理。  
（4）将 temp 中存储的数据插回systables 、syscolumns 、sysindices 、systabauth 、sysobjstate 、sysblobs 系统表中，伪表systabnames制作完成。
 
2.伪表的特殊之处  
（1）伪表systabnames制作完成之后，原来在磁盘上的表systabnames数据已经删除，此时伪表systabnames的数据存储在内存之中，这是由底层代码实现的。其存储在页面（page）的槽（slot）中，槽的大小为16字节（由代码推测）。  
（2）有的表可以创建索引之后再转化为伪表，需要再代码端看一下关于索引的处理。  
（3）每个伪表有各自的处理代码，可以说伪表是一个：**在内存上的高效组件，用于对特定数据的快速查询。**