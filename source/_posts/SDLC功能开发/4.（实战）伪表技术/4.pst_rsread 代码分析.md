# 一.pst_rsread 详细解读

## 1.函数定义与参数

mint pst_rsread(  
mint isfd, /* 文件描述符，标识被读取的分区 */  
setdesc_t *setp, /* 集合（伪表）的描述符 */  
char *row, /* 存储返回记录的缓冲区 */  
mint seqmode /* 顺序/访问模式标志 */  
)
 
- **功能**：从伪表中按行读取数据。  
- **参数**：  
- `isfd`：分区文件描述符，标识数据来源。  
- `setp`：描述伪表结构和状态的 `setdesc_t` 结构体指针。  
- `row`：存储读取记录的缓冲区。  
- `seqmode`：控制读取顺序（如顺序读、随机读等）。
 
## 2.变量声明

buf_hdr_t *bufptr; // 缓冲区头部指针  
tuple_hdr_t *tuple_hdrp; // 元组头部指针  
char *tuple_datap; // 元组数据指针  
mint ret_status; // 函数返回状态  
mint erase_tuple; // 标记是否擦除元组  
mint status; // 回调过滤状态  
ropen_t *sv_openp; // 保存全局打开状态  
rfile_t *sv_filep; // 保存全局文件状态  
rpartn_t *sv_partp; // 保存全局分区状态  
btree_t sv_btree; // 保存全局B树状态  
char tmpmsg1[ERR_LEN]; // 临时错误消息缓冲区
 
- **关键变量**：  
- `bufptr`：指向当前使用的缓冲区头部，管理元组的存储。  
- `tuple_hdrp` 和 `tuple_datap`：分别操作元组的元数据（如行号、状态）和实际数据。  
- `ret_status`：贯穿整个函数的错误状态码。
 
## 3.初始化与简单读取

bufptr = setp->sd_ibuffer; // 获取当前缓冲区  
ret_status = eOK;
 
/* 是否为逐行读取模式？ */  
if (setp->sd_style != SETREAD_NOCOPY) {  
if (pstread(isfd, row, seqmode))  
return(ret_status);  
return(ret_status);  
}
 
- **逻辑**：  
- 如果读取模式不需要缓冲区（`SETREAD_NOCOPY`），直接调用 `pstread` 逐行读取数据到 `row`。  
- 适用于单行读取或不需要复杂处理的场景。
 
## 4.错误预处理

if (setp->sd_err) {  
if (setp->sd_err == EINTERNAL) {  
return(setp->sd_err, ↓psread_exit_af);  
}  
else {  
return(setp->sd_err, ↓psread_exit);  
}  
}
 
- **逻辑**：  
- 如果之前已发生错误（`sd_err` 被设置），直接返回错误码。  
- `EINTERNAL` 表示严重内部错误，需跳转到 `psread_exit_af` 处理额外清理。
 
## 5.主循环：填充缓冲区

while (ret_status == eOK) {  
/* 在缓冲区分配空间 */  
buft_write(bufptr, tuple_hdrp, ret_status);
 
if (ret_status < 0) {  
/* 缓冲区不一致错误 */  
sprintf(tmpmsg1, s_pstreadwriteerr, ...);  
buft_error(bufptr, tmpmsg1);  
return(EINTERNAL, ↓psread_exit_af);  
}
 
/* 读取数据到元组 */  
tuple_datap = buft_row(tuple_hdrp);  
pstread(isfd, tuple_datap, seqmode);
 
if (rstcb->iserrno) {  
/* 处理读取错误 */  
setp->sd_err = rstcb->iserrno;  
if (bufptr->bh_tuple_count == 1)  
return(rstcb->iserrno, ↓psread_exit2);  
setiserrno(0);  
erase_tuple = TRUE;  
ret_status = eERROR;  
}  
// ... 其他逻辑  
}
 
- **逻辑**：  
1. **分配空间**：调用 `buft_write` 在缓冲区中为元组分配空间。  
2. **错误处理**：若分配失败，记录错误并返回 `EINTERNAL`。  
3. **读取数据**：通过 `pstread` 将数据读取到缓冲区。  
4. **错误标记**：若读取失败，标记错误并决定是否立即返回或继续。
 
## 6.过滤回调处理

if ((setp->sd_init) && (setp->sd_control.si_filter_func != NULL)) {  
/* 保存全局状态 */  
rsglobals_save(&sv_openp, &sv_partp, sv_filep, &sv_btree);  
/* 调用过滤函数 */  
status = (*setp->sd_control.si_filter_func)(...);  
/* 恢复全局状态 */  
rsglobals_restore(sv_openp, sv_partp, sv_filep, &sv_btree);
 
if (status != eOK) {  
// 处理过滤结果（如 EFILTERED、EBADFILTER）  
}  
}
 
- **逻辑**：  
- **回调函数**：用户定义的过滤函数 `si_filter_func` 对读取的数据进行处理。  
- **状态保存/恢复**：确保回调函数不会破坏全局上下文（如打开的文件、事务状态）。  
- **过滤结果处理**：根据返回值决定是否保留元组或标记错误。
 
## 7.元组擦除与清理

if (erase_tuple) {  
buft_erase(bufptr, status);  
if (status != eOK) {  
/* 缓冲区擦除失败 */  
sprintf(tmpmsg1, s_pstreaderaseerr, ...);  
buft_error(bufptr, tmpmsg1);  
return(EINTERNAL, ↓psread_exit_af);  
}  
}
 
- **逻辑**：若需擦除无效元组（如读取或过滤失败），调用 `buft_erase` 清理缓冲区空间。
 
## 8.返回结果与错误处理

*((buff_hdr_t **)row) = bufptr; // 返回缓冲区指针  
ret_status = eOK;
 
psread_exit:  
return(ret_status);
 
psread_exit_af:  
/* 内部错误处理：转储调试信息并触发警报 */  
afdump("setp", (char *)setp, sizeof(setdesc_t));  
if (bufptr)  
afdump("set read buffer", ...);  
sprintf(tmpmsg1, s_smisetreaderr, ...);  
affail_alarm(...);
 
psread_exit2:  
bufptr->bh_tuple_count = 0; // 重置元组计数  
return(ret_status);
 
- **逻辑**：  
- **正常返回**：将缓冲区指针存入 `row`，状态设为 `eOK`。  
- **错误处理**：  
- `psread_exit_af`：记录错误日志、触发警报，用于严重内部错误。  
- `psread_exit2`：清空缓冲区元组计数，防止后续错误传播。
 
## 9.关键设计点

1. **缓冲区管理**：  
- 使用 `buf_hdr_t` 结构管理缓冲区元数据（如元组数量、数据长度）。  
- 通过 `buft_write` 和 `buft_erase` 动态分配/释放元组空间。
 
2. **错误隔离**：  
- 错误分为可恢复（如 `EBADFILTER`）和不可恢复（如 `EINTERNAL`）。  
- 错误状态 (`sd_err`) 保存至下次读取，避免重复失败。
 
3. **回调机制**：  
- 用户可通过 `si_filter_func` 动态过滤数据，支持灵活的数据处理。  
- 全局状态保存/恢复确保回调不影响系统稳定性。
 
4. **伪表特性**：  
- 数据可能动态生成（如系统监控信息），无需物理存储。  
- 通过缓冲区批量读取提升性能，减少I/O开销。
 
## 10.总结

- **核心功能**：从伪表读取数据到缓冲区，支持过滤和批量处理。  
- **关键流程**：初始化 → 逐行读取（简单模式）→ 错误检查 → 缓冲区填充 → 过滤回调 → 错误清理 → 返回结果。  
- **设计亮点**：灵活的错误处理、回调机制、全局状态隔离。  
- **适用场景**：系统监控、元数据查询、动态生成数据的虚拟表。
 
==mint pst_rsread(==  
    ==mint isfd,                /* file descriptor for partition being read */==  
    ==setdesc_t *setp,==          ==/* description of set read */==  
    **char** ==*row,                /* destination for returned record */==  
    ==mint seqmode              /* sequence/access mode flags */==  
==)==  
=={==  
    ==buf_hdr_t *bufptr;         /* ptr to header of set read buffer */==  
    ==tuple_hdr_t *tuple_hdrp;==  ==/* pointer to tuple header */==  
    **char** ==*tuple_datap;        /* pointer to tuple data */==  
    ==mint ret_status;==          ==/* procedure return status */==  
    ==mint erase_tuple;         /* boolean flag, reclaim buff space */==  
    ==mint status;==              ==/* from callback filter */==  
    ==ropen_t *sv_openp;==  
    ==rfile_t *sv_filep;==  
    ==rpartn_t *sv_partp;==  
    ==btree_t sv_btree;==  
    **char** ==tmpmsg1[ERR_LEN];    /* temporary message buffer */==
 
    ==bufptr = setp->sd_ibuffer;==  
    ==ret_status = eOK;==
 
    ==/* Is this record-by-record read? */==  
    **if** ==(setp->sd_style != SETREAD_NOCOPY) {==  
        **if** ==(pstread(isfd, row, seqmode))==  
            **return**==(ret_status);==  
        **return**==(ret_status);==  
    ==}==
 
    ==/* If an error was encountered while previously filling the buffer, then that's all. */==  
    **if** ==(setp->sd_err) {==  
        **if** ==(setp->sd_err == EINTERNAL) {==  
            **return**==(setp->sd_err, ↓psread_exit_af);==  
        ==}==  
        **else** =={==  
            **return**==(setp->sd_err, ↓psread_exit);==  
        ==}==  
    ==}==
 
    ==/* start filling set read buffer */==  
    **while** ==(ret_status == eOK) {==  
        ==/* allocate space in the record buffer */==  
        ==buft_write(bufptr, tuple_hdrp, ret_status);==
 
        **if** ==(ret_status <== ==0====) {==  
            ==/* buffer inconsistency was detected */==  
            ==sprintf(tmpmsg1, s_pstreadwriteerr,==  
                ==(int4)setp->sd_style, (int4)ret_status);==  
            ==buft_error(bufptr, tmpmsg1);==  
            **return**==(EINTERNAL, ↓psread_exit_af);==  
        ==}==
 
        ==/* put the row in the data area immediately after the tuple header */==  
        ==tuple_datap = buft_row(tuple_hdrp);==  
        ==pstread(isfd, tuple_datap, seqmode);==
 
        **if** ==(rstcb->iserrno) {==  
            ==/* If we have tuples to return, save the error for the next buffer request. */==  
            ==setp->sd_err = rstcb->iserrno;==  
            **if** ==(bufptr->bh_tuple_count ==== ==1====)==  
                **return**==(rstcb->iserrno, ↓psread_exit2);==
 
            ==setiserrno(====0====);==  
            ==erase_tuple === **TRUE**==;==  
            ==ret_status = eERROR;==  
        ==}==  
        **else** =={==  
            ==erase_tuple === **FALSE**==;==
 
            **if** ==((setp->sd_init) && (setp->sd_control.si_nrows !=== **NULL**==))==  
                ==(*setp->sd_control.si_nrows)++;==
 
            **if** ==((setp->sd_init) &&==  
                ==(setp->sd_control.si_filter_func !=== **NULL**==)) {==  
                ==/* apply filtering callback routine */==  
                ==rsglobals_save(&sv_openp, &sv_partp, sv_filep, &sv_btree);==  
                ==status = (*setp->sd_control.si_filter_func)==  
                    ==(tuple_datap, PARTP->pt_partnum, rstcb->isrecnum,==  
                     ==setp->sd_control.si_filter_desc);==  
                ==rsglobals_restore(sv_openp, sv_partp, sv_filep, &sv_btree);==
 
                **if** ==(status != eOK) {==  
                    **if** ==(status == EFILTERED) {==  
                        ==ret_status = eOK;==  
                    ==}==  
                    **else if** ==(status == EBADFILTER) {==  
                        ==/* problems with the filter==  
                         ==* If we have tuples to return, save the error for the next buffer request.==  
                         ==*/==  
                        ==setp->sd_err = EBADFILTER;==  
                        **if** ==(bufptr->bh_tuple_count ==== ==1====)==  
                            **return**==(EBADFILTER, ↓psread_exit2);==
 
                        ==setiserrno(====0====);==  
                        ==ret_status = eERROR;==  
                    ==}==  
                    **else** =={==  
                        ==afmsgi("pst_rsread:filter_func error, status = %d",==  
                               ==(int4)status,== ==0L====);==  
                        ==/* If we have tuples to return, save the error for the next buffer request. */==  
                        ==setp->sd_err = EINTERNAL;==  
                        **if** ==(bufptr->bh_tuple_count ==== ==1====)==  
                            **return**==(EINTERNAL, ↓psread_exit_af);==
 
                        ==setiserrno(====0====);==  
                        ==ret_status = eERROR;==  
                        ==erase_tuple === **TRUE**==;==  
                    ==}==  
                ==} /* end if (status != eOK) */==  
            ==} /* end if (setp->sd_init) && (set...) */==  
        ==} /* end else */==  
        **if** ==(erase_tuple) {==  
            ==/* erase the tuple in buffer 0 */==  
            ==buft_erase(bufptr, status);==  
            **if** ==(status != eOK) {==  
                ==/* buffer inconsistency was detected */==  
                ==sprintf(tmpmsg1, s_pstreaderaseerr,==  
                    ==(int4)setp->sd_style, (int4)status);==  
                ==buft_error(bufptr, tmpmsg1);==  
                **return**==(EINTERNAL, ↓psread_exit_af);==  
            ==}==  
            **else** =={==  
                ==tuple_hdrp->th_rowid = rstcb->isrecnum;==  
                ==tuple_hdrp->th_fragid = PARTP->pt_partnum;==  
                ==tuple_hdrp->th_status === ==0====;==  
            ==}==  
        ==} /* end if (erase_tuple) */==  
    ==} /* end while ret_status == eOK */==
 
    ==/* return pointer to the buffer */==  
    ==*((buff_hdr_t **)row) = bufptr;==  
    ==ret_status = eOK;==
 
==psread_exit:==  
    **return**==(ret_status);==
 
==psread_exit_af:==  
    ==/* internal error occurred somewhere along the line */==  
    ==afdump(===="setp"====, (==**char** ==*)setp,== **sizeof**==(setdesc_t));==  
    **if** ==(bufptr)==  
        ==afdump(===="set read buffer (bufptr)"====, (==**char** ==*)bufptr,==  
            ==ALIGN_UDT_ROW(==**sizeof**==(buft_hdr_t)) + bufptr->bh_data_length);==  
    ==sprintf(tmpmsg1, s_smisetreaderr, PARTP->pt_partnum);==  
    ==affail_alarm(ALRM_SUBS,== =="SMI"====, ALRM_ATTENTION,==  
        ==tmpmsg1, s_readopfailed, s_techsupport, ALRMU_6_SMISETREADERR);==
 
==psread_exit2:==  
    ==bufptr->bh_tuple_count === ==0====;==  
    **return**==(ret_status);==  
==} /* end pst_rsread */==