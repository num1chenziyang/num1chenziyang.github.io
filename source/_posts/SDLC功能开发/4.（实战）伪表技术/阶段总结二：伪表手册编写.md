# 一.问题背景

## 1.视图 USER_VIEWS 伪表化

==每次查询视图时，数据库都会根据视图的定义动态生成数据。==现在视图查询速度过慢，将视图伪表化可以解决此类问题。使用伪表技术来优化视图的关键在于：将频繁访问但计算成本高的视图转换为伪表形式。这种方法特别适用于那些查询模式固定且数据变化不频繁的应用场景。下面讨论伪表技术。
    
# 二.伪表技术介绍

## 1.什么是 Pseudo Tables？

在数据库系统中，**pseudo tables（伪表）** 指的是那些不直接在物理存储上持久化的表。这些表可以用于：  
**内部元数据管理**：如跟踪数据库运行时的信息、事务状态、系统配置等。  
**虚拟化表功能**：提供类似物理表的访问接口，但实际可能由其他数据结构支持。  
**优化性能**：伪表可以绕过某些普通表的存储和索引开销，提升运行效率。  
**特殊用途**：某些伪表可能用于调试、监控、或支持高级功能（如分布式查询）。  
 
## 2.具体操作步骤分析

### （1）创建流程

创建表和索引：  
初始化一个普通表结构，并为其创建索引。这是伪表的基本骨架。  
创建索引可能是为了模拟或支持伪表的查询行为，但它不一定真正用于存储或物理排序。  
调整权限：  
收回对表的所有权限，确保其他用户无法在创建或初始化期间对其进行操作。  
然后赋予最低权限（查询权限），确保伪表只能被访问而不能被修改。  
提取元数据到临时表：  
将该表的元数据（systables、syscolumns 等）复制到临时表中，提供一个安全的修改缓冲区。这避免了直接操作系统表可能引发的不一致或并发问题。  
修改 partnum 和 nrows：  
修改 partnum：  
partnum 通常标识表的物理存储位置或分区编号。将其设置为特定值（如 154），可能是为了告诉数据库引擎这不是一个普通表，而是一个伪表。  
注释中提到的 “reset partnums” 表明这是伪表识别的关键步骤。  
修改 nrows：  
伪造一个特定的行数（如 100），可能用于欺骗引擎的优化器或其他系统模块，让其认为这个伪表有固定的行数。  
删除原表：  
删除原表后，系统表中的元数据仍然保留（因为这些已经被插入到临时表中）。  
将临时表数据重新插入系统表：  
将伪表的元数据写回 systables 和其他相关系统表，完成对伪表的标识和注册。  
此时，数据库引擎会将其视为伪表，而不再尝试为其分配实际的物理存储。  
删除临时表：  
清理缓冲区，确保环境整洁，不影响其他操作。
 
### （2）创建 sql

_1.将partnum连接到表名_

{join for partnums to table names}   create table gbasedbt.systabnames  
{  
partnum integer, {table id for table}  
dbsname char(128), {database name}  
owner char(32), {table owner}  
tabname char(128), {table name}  
collate char(32), {collation assoc with database}  
dbsnum intager {dbspace number}  
};  
create unique index gbasedbt.systabs_pnix on systabnames(partnum);  
create index gbasedbt.systabs_pnix2 on systabnames(dbsnum);  
revoke all on gbasedbt.systabnames from public as gbasedbt;  
grant select on gbasedbt.systabnames to public as gbasedbt;   create table ......  

_2.从目录中获取信息并保存_

{get info out of catalogs and save it}   select tabid from systables where tabname in ('systabnames','syscdr_ddr','syssmx'**......**) into temp temptabid with no log;  
select * from systables where **tabid** in (select tabid from temptabid) into temp tempsystab with no log;  
select * from syscolumns where **tabid** in (select tabid from temptabid) into temp tempsyscol with no log;  
select * from sysindices where **tabid** in (select tabid from temptabid) into temp tempsysidx with no log;  
select * from systabauth where **tabid** in (select tabid from temptabid) into temp tempsysauth with no log;  
select * from sysobjstate where **tabid** in (select tabid from temptabid) into temp tempsysobj with no log;  
select * from sysblobs where **tabid** in (select tabid from temptabid) into temp tempsysblobs with no log;  

_3.重置partnums，在内部便可将其识别为伪表，并在优化器中更新列表_

{reset partnums so internally we recognize these as pseudo tables, also update nrows to clue in the optimizer}   update tempsystab set (partnum, nrows) = (15, 1000) where tabname = 'systabnames';  
update tempsystab ......  
drop table systabnames;  
--此处删除后 systabnames 表后，systables、syscolumns等系统表关于其的信息也一并删除了  
drop table ......  

_4.将修改后的目录信息重新插入目录中_

{reinsert modified catalog info into catalogs}   insert into systables select from tempsystab;  
insert into syscolumns select from tempsyscol;  
insert into sysindices select from tempsysidx;  
insert into systabauth select from tempsysauth;  
insert into sysobjstate select from tempsysobj;  
insert into sysblobs select from tempsysblobs;  
--此时systabnames的伪表已经做成  
drop table tempsystab;  
drop table tempsyscol;  
drop table tempsysidx;  
drop table tempsysauth;  
drop table tempsysobj;  
drop table tempsysblobs;  

_note：_

1.伪表制作步骤简述：  
（1）temp 将systabnames表存储在systables 、syscolumns 、sysindices 、systabauth 、sysobjstate 、sysblobs 系统表中的信息全部储存了起来（也可以说 temp 存储了systabnames表的元数据）。  
（2）修改partnum与nrows，创立了伪表的标识。  
（3）将systabnames本体删除，其在systables 、syscolumns 、sysindices 、systabauth 、sysobjstate 、sysblobs 系统表中的信息被清理。  
（4）将 temp 中存储的数据插回systables 、syscolumns 、sysindices 、systabauth 、sysobjstate 、sysblobs 系统表中，伪表systabnames制作完成。   2.其他  
（1）伪表systabnames制作完成之后，原来在磁盘上的表systabnames数据已经删除，此时伪表systabnames的数据存储在内存之中，这是由底层代码实现的。其存储在页面（page）的槽（slot）中，槽的大小为16字节（由代码推测）。  
（2）有的表可以创建索引之后再转化为伪表，需要再代码端看一下关于索引的处理。  
（3）每个伪表有各自的处理代码，可以说伪表是一个：在内存上的高效组件，用于对特定数据的快速查询。
   

## 3.为什么要这样设计？

### 1.元数据临时存储（Temp Tables）

目的：避免直接修改系统表（如`systables`、`syscolumns`等）导致的数据不一致或并发冲突。  
操作：  
-- 提取原表元数据到临时表  
SELECT * FROM systables INTO TEMP tempsystab;  
SELECT * FROM syscolumns INTO TEMP tempsyscol;  
技术原理：  
- 临时表作为缓冲区，隔离对系统表的直接操作，确保原子性（类似事务的中间状态）。  
- 修改元数据时（如`partnum`），仅在临时表中进行，避免污染系统表。
 
### 2.伪表标识注入

目的：  
<1>partnum重定向：普通表的 partnum 指向物理存储位置（如磁盘页），而伪表设为特殊值（如154），告知存储引擎无需分配物理空间（代码中通过 partnum 判断是否为伪表，触发内存分配逻辑）。  
<2>nrows 欺骗优化器：伪造行数（如1000）可辅助查询优化器生成更合理的执行计划（如内存分配、JOIN顺序）。  
操作：  
-- 修改 partnum（分区号）和 nrows（行数）  
UPDATE tempsystab SET partnum=154, nrows=1000 WHERE tabname='systabnames';
 
### 3.物理存储解耦

目的：解除表与磁盘文件的绑定，减少物理IO开销。  
操作：  
-- 删除原表与元数据清理  
DROP TABLE systabnames; -- 删除原表物理文件及系统表记录  
-- 伪表元数据重新注册  
INSERT INTO systables SELECT * FROM tempsystab; -- 重新注册伪表元数据  
技术细节：  
- 系统表（如`systables`）将伪表视为普通表，但`partnum`特殊值触发存储引擎的特殊处理。  
- 伪表数据由底层代码动态生成（如内存结构、回调函数），不依赖物理文件。
 
### 4.权限控制与安全性

目的：防止用户误操作（如`INSERT`/`UPDATE`）破坏伪表动态数据的一致性；保持伪表的只读性，确保其作为虚拟表的逻辑正确性。  
操作：  
REVOKE ALL ON systabnames FROM PUBLIC; -- 收回所有权限  
GRANT SELECT ON systabnames TO PUBLIC; -- 仅开放查询权限
 
### 5.系统表结构的一致性

目的：将伪表注册到系统表（如 systables, syscolumns），可以让伪表看起来和普通表一致。这有助于提高兼容性，让其他模块可以透明地访问伪表。
                              
 **二.伪表的数据处理**  
**1.伪表的数据来源**  
**伪表的数据来源于内存中的结构**：  
**伪表通常直接映射到数据库引擎的内部内存结构（如系统缓存、内存中的数据字典、运行时状态等）。**  
**当用户查询伪表时，数据库引擎会将伪表的查询翻译为对这些内存结构的直接访问，而不是读取磁盘上的存储。**  
**伪表的数据是动态生成的**：  
**对伪表的查询结果通常由引擎的代码实时生成，而不是从固定存储中检索。例如：**  
**systables 等伪表可能实时读取引擎维护的表和元数据结构。**  
**性能监控伪表（如记录查询统计的伪表）可能实时读取引擎中的性能计数器或统计信息。**  
**伪表依赖特定的代码路径**：  
**每个伪表都可能有特定的实现代码，在伪表被查询时，这些代码会被调用以生成查询结果。**     
**2.伪表的数据更新方式**  
**实时更新**：  
**伪表的数据更新由引擎的运行状态或操作驱动。例如：**  
**如果伪表反映的是当前的事务状态，每当事务发生变化（如提交或回滚），相关的内存结构就会实时更新。**  
**如果伪表记录的是查询执行的统计信息，每次查询运行时，统计信息都会在内存中更新。**  
**内存结构更新**：  
**伪表依赖的内存结构通常由数据库的内部组件主动维护：**  
**系统元数据伪表：由数据库的元数据管理模块更新。**  
**性能监控伪表：由性能监控模块更新。**  
**运行时状态伪表：由事务管理器、调度器等模块更新。**  
**触发更新**：  
**某些伪表可能在特定操作或事件时触发更新：**  
**插入、更新或删除某个普通表时，伪表的数据可能会反映这些变更。**  
**特定的管理操作（如收缩表空间、更新统计信息）可能触发伪表数据的刷新。**     
**3.伪表的工作机制**  
伪表在查询时并不直接访问物理存储，而是遵循以下流程：  
**SQL 查询解析**：  
**当用户执行查询伪表的 SQL 语句时，SQL 解析器会识别伪表，并将其与普通表区分开来。**  
**特定查询执行计划**：  
**查询引擎会为伪表生成特殊的执行计划，跳过存储层，直接调用内存数据或内部函数。**  
**数据生成或映射**：  
**查询执行时，伪表对应的引擎模块会被调用，通过映射内存结构、计算或读取系统状态，动态生成伪表的返回数据。**     
**4.举例说明**  
**示例 1：系统元数据伪表**  
伪表：systables  
数据来源：数据库的系统数据字典，存储在内存中。  
数据更新：当用户创建、删除或修改表时，引擎会实时更新数据字典。  
查询操作：  
SELECT * FROM systables WHERE tabname = 'my_table';  
执行流程：  
SQL 解析器识别 systables 为伪表。  
查询引擎直接访问内存中的系统数据字典，检索对应信息。  
返回查询结果。   **示例 2：性能监控伪表**  
伪表：sysmon  
数据来源：引擎的性能统计模块，实时记录 CPU、IO 等指标。  
数据更新：引擎定期或在相关事件发生时更新性能统计信息。  
查询操作：  
SELECT cpu_usage, io_wait FROM sysmon;  
执行流程：  
SQL 解析器识别 sysmon 为伪表。  
查询引擎调用性能监控模块，读取当前的性能计数器值。  
返回查询结果。     
**5.为什么伪表只提供查询权限？**  
伪表的核心功能是**反映系统状态**，因此它们通常是只读的：  
**安全性**：  
防止用户误操作或恶意修改伪表内容，导致系统行为异常。  
**数据来源限制**：  
伪表数据通常是动态生成的，无法支持插入、更新或删除操作。  
**设计意图**：  
伪表的用途是提供信息，而非存储数据。   **6.总结**  
伪表的数据来自于数据库引擎的内存结构或实时生成，不占用物理存储空间。  
它们的数据更新是由引擎模块维护的内存结构自动驱动，且在查询时动态生成返回结果。伪表的查询权限是为了保证数据的一致性和安全性，同时强调其只读性质。     
**一.操作流程概述**  
**sysmaster.sql**  
**创建表（可以创建索引）**：  
先创建一个表，也可以创建索引。  
**收回权限并重新赋予查询权限**：  
收回对表的所有权限后，仅赋予查询权限，限制后续的操作范围，确保后续插入的系统表数据不会被误改。  
**从系统表提取元数据并插入临时表**：  
将目标表的元数据（如列信息、索引、权限、状态、BLOB 信息等）从系统表中提取并存储到临时表中。  
**修改临时表中的元数据**：  
修改 tempsystab 中 tabid 对应的 partnum 和 nrows 的值，以获取伪表特征。  
**删除原表并还原系统表中的元数据**：  
删除创建的表后，再将临时表中的数据插入回系统表，完成对系统表的直接更新。  
**删除临时表**：  
清理临时表，恢复干净的环境。