# 一.Gbase8s 物理存储结构

**【GBase8s】 存储结构介绍和onspaces命令的实践案例**  
[https://www.modb.pro/db/638652#chunk_14](https://www.modb.pro/db/638652#chunk_14)
 ![GBase 8s Instance d bspace d bspace Chunk Extent Chunk 0 到 00 Chunk Page Tables ace 个 GBase 8s 实 例 Instance 可 以 创 建 多 个 dbspaces, 一 个 dbspace 可 以 包 含 多 个 物 理 chunks, 个 chunk 分 成 多 个 连 续 扩 展 区 e × tents ， 一 个 表 或 者 索 引 占 用 的 空 间 被 称 为 一 个 tablespace, I exte nt 包 含 多 个 物 理 页 pageso 其 中 ， dbspace 、 tablespace 和 extent 属 于 逻 辑 存 储 单 元 ； chunk 和 pag e 属 于 物 理 存 储 单 元 。 1 · 1 · 物 理 存 储 单 元 chunk chunk 就 是 用 于 存 储 数 据 的 连 续 磁 盘 空 间 （ 物 理 磁 盘 最 大 单 元 ） ， 是 存 储 数 据 库 数 据 的 文 件 或 者 裸 设 备 。 个 chunk 可 以 是 一 个 裸 设 备 (raw device) 或 者 一 个 UNI × 文 件 (cooked file)0 一 个 chunk 最 大 可 以 是 4 TB, 最 多 可 以 有 32767 个 chunk 。 root chunk 包 含 整 个 数 据 库 保 留 页 及 系 统 表 等 信 息 。 一 般 将 物 理 日 志 逻 辑 日 志 迁 移 到 单 独 的 dbspace 上 。 root chunk 存 储 格 式 如 下 图 所 示 ． Layout Ofa Root Chunk Reserved Tblspace Logical Database logs pages tblspace tblspace sysmaster Chunk free Physical sysutils list page sysuser sysadmin 一 个 非 root chunk 主 要 存 储 表 、 索 引 的 数 据 (Tablespace), 划 分 为 多 个 连 续 的 extent 。 非 root chunk 的 存 储 格 式 如 下 图 所 示 · Layout Of a Non-Root Chunk First chunk in dbspace Chunk Tblspace Tblspace Reserved free list tblspace extents pages Subsequent chunks in dbspace sysadmin 库 中 task() 函 数 针 对 chunk 有 四 种 使 用 方 法 （ 同 admin() 函 数 ） ． 1 、 设 置 可 扩 展 ． EXECUTE FUNCTION task ('modify chunk extendable' 14 其 中 ， 14 是 chunkID, 另 外 ， 如 果 不 设 置 chunk 为 自 动 扩 展 ， 那 么 当 chunk 空 间 用 完 后 ， 会 自 动 新 增 一 chunk0 2 、 取 消 可 扩 展 ． EXECUTE FUNCTION task("modify chunk extendable off" 3 、 手 动 扩 展 大 小 ： EXECUTE FUNCTION task ("modify space expand" "testchunkl" " 1000KB " 4 、 更 改 可 扩 展 大 小 ： EXECUTE FUNCTION task "modify "dbspace31' " 60000 " " 10000 " " 10000 引 Z e S " space S p_ extent extent 就 是 物 理 上 连 续 数 据 页 的 集 合 ， tablespace （ 表 和 索 引 ） 的 存 储 空 间 是 以 extent 为 单 位 来 分 配 的 。 如 下 图 所 示 ， 在 创 建 customer 表 时 ， 数 据 库 会 根 据 extent size 确 定 该 表 初 始 的 空 间 ， 默 认 大 小 是 8 页 。 当 向 customer 表 中 不 断 insert 记 录 时 ， 为 表 customer 分 配 的 空 间 将 被 使 用 完 ， 此 时 ， 数 据 库 需 要 为 表 扩 展 新 的 空 间 ， GBase 8s 以 e × tent 为 单 位 进 行 扩 展 ， 我 们 可 以 用 next size 来 指 定 表 每 次 空 间 扩 展 的 大 小 ， 默 认 大 小 也 是 8 页 ， 个 extent 包 含 若 干 物 理 上 连 续 的 数 据 页 。 最 大 的 extent 数 为 32767 。 customer chunk Insert into customer values ， Insert into customer values ， ， tablespace Insert into customer values ， ， 扩 展 存 储 空 间 ： Extent 到 00000 到 0 Extent 下 个 示 例 为 在 testchunk3 数 据 库 空 间 上 创 建 一 个 表 t3 ， 并 指 定 extent size 大 小 为 20KB, next size 大 / 」 \ 为 10KB ． CREATE TABLE t3 （ id int name VARCHAR(2Ø)) IN testchunk3 EXTENT SIZE 20 NEXT SIZE 1@ 下 图 显 示 数 据 库 服 务 器 如 何 为 扩 展 数 据 块 分 配 6 个 页 ： 1 、 扩 展 数 据 块 总 是 完 全 包 含 在 一 个 块 中 ； 扩 展 数 据 块 不 能 穿 过 块 的 边 界 。 2 、 如 果 数 据 库 服 务 器 找 不 到 指 定 给 下 一 个 扩 展 数 据 块 大 小 的 连 续 磁 盘 空 间 ， 那 么 它 将 在 数 据 库 空 间 的 下 一 个 块 中 搜 索 连 续 的 空 间 。 块 2 扩 展 数 据 块 曲 曲 使 亠 6 在 窄 的 图 白 曲 、 续 色 以 一 烛 顶 己 允 艹 中 续 灬 找 的 一 6 用 “ 展 块 “ 个 连 面 page 数 据 页 Page 是 基 本 的 存 储 单 元 ， 是 最 小 的 丨 / 0 单 元 ， 如 下 图 所 示 。 GBase 8s 进 行 一 次 | / 0 的 最 小 单 元 为 一 I page, 即 使 我 们 只 对 一 个 page 里 的 某 一 行 记 录 进 行 了 修 改 ， GBase 8s 也 需 要 对 整 个 数 据 页 进 行 读 取 到 内 存 和 写 入 到 磁 盘 。 磁 盘 的 一 个 数 据 页 读 取 到 内 存 就 会 分 配 一 个 同 样 大 小 的 内 存 page 来 存 储 。 GBase 8s 支 持 不 同 大 小 的 数 据 页 ： 2kB 、 4kB 、 8kB 、 16kB0 在 大 多 数 的 UNI × 系 统 中 ， 缺 省 的 数 据 页 大 小 是 2KB 。 Memo Page 以 Page 为 单 位 进 行 | ℃ 读 、 写 所 有 的 数 据 库 和 系 统 信 息 被 存 储 在 数 据 页 上 ， 表 的 记 录 、 索 引 的 | nde × 一 key 都 以 Page 为 存 储 单 位 进 行 存 储 管 理 。 一 个 数 据 页 的 内 部 存 储 结 构 如 下 图 所 示 ， 一 个 数 据 页 总 体 上 分 成 三 部 分 ： 页 头 、 页 尾 和 数 据 部 分 。 Page Address nslots pfree nfree FLAG CHKSUM Previous page Next page DATA Slots Slot Bitmap 引 Ot Bitmap timestamp 对 页 头 的 解 释 如 下 。 数 据 页 头 总 共 占 用 24 Byte 的 空 间 ， 由 8 个 部 分 组 成 ： 1 、 Page Address ： 存 储 页 的 地 址 信 息 ， 占 用 6 Byte ， 由 两 部 分 组 成 ： chunknum+pageoffsize chunknum 占 用 2 Byte, 包 含 了 符 号 位 ， 故 支 持 的 最 大 chunk 数 为 FFFF / 2 = 32767 ， 也 就 是 说 一 个 GBase 8s 实 例 最 多 可 以 支 持 32767 个 chunk 。 pageoffszie 占 用 4 Byte ， 故 一 个 chunk 的 最 大 页 数 FFFFFFFF 去 掉 符 号 位 =2 的 31 次 方 ： 2 billion, 对 于 2k 的 pagesize, 最 大 的 空 间 为 4T = 2 的 31 次 方 * 2K = 2147483648 * 2k 。 2 、 CHKSUM: 校 验 位 ， 占 用 2 Byteo 3 、 FLAG: 标 记 位 ， 占 用 2 Btye, 标 识 该 数 据 页 存 储 的 是 表 的 数 据 （ DATA ） 或 者 索 引 （ BTREE ） 。 记 录 数 计 数 器 ， 占 用 2 Byte ， 记 录 该 数 据 页 总 共 存 储 的 记 录 数 。 4 、 Nslots: 即 Pointer of first free slots ， 占 用 2 Byte ， 用 来 指 向 页 内 第 一 个 空 闲 的 引 Ots 在 页 内 的 偏 移 5 、 Pfree ． number of free slots, 占 用 2 Byte, 页 内 总 共 空 闲 的 引 Ots 数 量 。 6 、 Nfree ． 7 、 Next Page: 占 用 4 Btye, 指 向 下 页 的 地 址 ， 对 于 数 据 页 为 0 ， 对 于 索 引 页 则 指 向 下 一 个 节 / 飞 、 0 8 、 Previous Page ： 占 用 4 Btye ， 执 行 前 页 地 址 ， 对 于 数 据 页 存 储 0 ， 对 于 索 引 页 则 存 储 前 页 地 址 。 对 页 尾 的 解 释 如 下 ： 数 据 页 尾 由 两 部 分 组 成 ： 时 间 戳 和 每 个 slots 的 描 述 信 息 。 1 、 timestamp: 时 间 戳 ， 占 用 4 Byte ， 描 述 数 据 页 的 更 新 时 间 。 2 、 slots table: 为 slots 描 述 信 息 ， 数 据 页 中 有 多 少 slots, 则 会 对 应 多 少 个 slots bitmap, 每 个 占 用 4 Byte ， 记 录 slots 在 页 内 的 偏 移 地 址 和 长 度 ， 当 记 录 被 删 除 时 ， 只 是 将 其 中 的 占 用 长 度 设 置 为 0 ， 在 物 理 上 并 没 有 将 记 录 信 息 清 空 。 对 数 据 部 分 的 解 释 如 下 ： 1 、 在 数 据 页 中 用 来 存 储 数 据 的 部 分 可 以 存 储 行 记 录 和 索 引 key 。 2 、 以 slots 的 方 式 分 成 n 个 存 储 单 元 ， 每 个 slots 存 放 一 行 记 录 或 者 一 个 index-key0 3 、 在 一 个 数 据 页 中 最 多 能 存 储 255 个 引 Ots 。 ](Exported%20image%2020250328134916-0.jpeg)     

# 二.分析

## 对 USER_VIEWS 伪表化（假设USER_VIEWS 的创建仅依靠 systables）

## 1.原伪表创建流程与任务不适配

在 sysmaster 下本来就存在的伪表，其流程与 USER_VIEWS 伪表化任务并不适配，原因如下：  
（1）原始伪表中可用的现成数据太少，不能支持创建视图这种复杂的结构伪表化。  
（2）原伪表是对所有 chunk 进行搜索，而 VIEW 伪表化需要在指定的库进行搜索。
   

## 2.下一阶段目标

分析 rsread 函数，通过 gdb 调试 select * from systables 语句，目的是：  
（1）理清数据读取的具体流程，看如何定位数据位置、如何取出数据。
       
join 和 union all 解决了就没什么问题了