---
title: 3.make与cmake
date: 2025-04-09 17:07:09
categories:
  - SDLC编译工作
  - 编译知识体系
tags:
  - 编译
password: 9761565829chen
---
# （一）make与CMake的全面对比与分析
## 1. **核心定位与角色差异**
• **Make**  
  • **执行者角色**：Make 是一个直接构建工具，通过读取 `Makefile` 文件中的规则执行编译、链接等操作。它仅负责按预设指令完成任务，例如生成可执行文件或库。  
  • **依赖文件**：开发者需手动编写 `Makefile`，明确指定源文件、目标文件及依赖关系，例如：  
```makefile
    hello: main.o utils.o
        g++ main.o utils.o -o hello
```  
这种语法要求开发者对编译流程和平台特性有较高理解。

• **CMake**  
  • **生成者角色**：CMake 是一个跨平台的构建系统生成器，不直接编译代码，而是根据 `CMakeLists.txt` 生成适用于不同平台的构建文件（如 `Makefile`、Visual Studio 项目等）。  
  • **抽象化构建**：通过高级语法（如 `add_executable()`、`target_link_libraries()`）描述项目结构，屏蔽底层平台差异。例如：  
```cmake
    cmake_minimum_required(VERSION 3.10)
    project(MyProject)
    add_executable(my_app main.cpp utils.cpp)
```  
这种设计让开发者无需关注具体编译器命令。


## 2. **核心功能对比**
| **特性**    | **Make**          | **CMake**                     |
| --------- | ----------------- | ----------------------------- |
| **构建文件**  | 直接使用 `Makefile`   | 生成 `Makefile` 或其他构建系统文件       |
| **跨平台支持** | 依赖手动调整 `Makefile` | 自动适配不同平台（Windows/macOS/Linux） |
| **依赖管理**  | 需显式编写依赖规则         | 自动检测外部库（如 find_package()）     |
| **语法复杂度** | 低（简单命令，但需处理细节）    | 高（支持条件语句、循环、函数等）              |
| **适用场景**  | 小型项目或单平台维护        | 大型跨平台项目（如开源库、多架构软件）           |


## 3. **构建流程差异**
• **Make 的典型流程**：  
  1. 编写 `Makefile`，定义编译规则。  
  2. 执行 `make` 命令，直接编译生成目标文件。  
  ```bash
  make -j4  # 使用4线程加速编译
  ```

• **CMake 的典型流程**：  
  1. 编写 `CMakeLists.txt`，描述项目结构。  
  2. 运行 `cmake` 生成构建文件（如 `Makefile`）。  
  3. 调用 `make` 或其他工具（如 `ninja`）进行实际编译。  
  ```bash
  mkdir build && cd build
  cmake .. -DCMAKE_BUILD_TYPE=Release
  make
  ```


## 4. **高级特性对比**
• **Make 的灵活性与局限**  
  • **优势**：轻量级，适合快速调试；可通过 `-j` 选项实现多核并行编译。  
  • **局限**：跨平台需大量条件判断（如区分 `gcc` 与 `cl` 编译器命令），维护成本高。

• **CMake 的扩展能力**  
  • **模块化**：支持代码复用（如 include() 引入通用配置）。  
  • **选项控制**：通过 option() 定义编译开关，例如：  
```cmake
    option(USE_OPENMP "Enable OpenMP support" ON)
    if(USE_OPENMP)
        find_package(OpenMP REQUIRED)
        target_link_libraries(my_app OpenMP::OpenMP_CXX)
    endif()
```  
用户可通过 -DUSE_OPENMP=OFF 动态禁用功能。  
  • **依赖管理**：集成 `FetchContent` 或 `vcpkg` 实现第三方库自动下载。


## 5. **典型应用场景**
• **Make 适用场景**：  
  • 嵌入式开发（需精细控制编译参数）。  
  • 单平台脚本工具（如 Linux 内核模块编译）。

• **CMake 适用场景**：  
  • 跨平台框架（如 Qt、OpenCV）。  
  • 多组件项目（如主程序 + 测试套件 + 文档生成）。


## 6. **总结：互补而非替代**
两者通常协同工作：CMake 生成 Makefile，再由 Make 执行编译。这种分层设计既保留了 Make 的高效性，又通过 CMake 解决了跨平台难题。对于现代开发，CMake 已成为事实标准，尤其在与 IDE（如 CLion、VS Code）集成时优势显著。

---

# （二）Makefile与CMakeLists.txt
## 一、Makefile 与 CMakeLists.txt 的区别
**Makefile** 是直接定义构建规则和依赖关系的脚本（需手动编写编译命令），而 **CMakeLists.txt** 是跨平台的构建配置描述文件（通过 CMake 生成 Makefile 或其他构建文件）。


## 二、如何阅读 Makefile
#### **1. 核心语法与结构**
• **规则定义**：
  ```makefile
  target: dependencies
      command  # 必须以 Tab 开头（不能是空格）
  ```
  • **target**：目标文件（如 `main.o`）或伪目标（如 `clean`）。
  • **dependencies**：构建目标所需的文件或其他目标。
  • **command**：执行的 Shell 命令（如 `gcc -c main.c`）。

• **变量**：
  ```makefile
  CC = gcc
  CFLAGS = -Wall
  OBJ = main.o utils.o

  $(CC) $(CFLAGS) -o program $(OBJ)
  ```

• **自动变量**（简化规则）：
  • `$@`：当前目标名（如 `main.o`）。
  • `$<`：第一个依赖文件（如 `main.c`）。
  • `$^`：所有依赖文件。

• **伪目标**（不生成文件）：
  ```makefile
  .PHONY: clean
  clean:
      rm -f *.o program
  ```

#### **2. 阅读步骤**
1. **定位入口目标**：
   • 查找默认目标（通常是第一个规则或名为 `all` 的目标）。
   • 示例：
     ```makefile
     all: program  # 默认构建 program
     ```

2. **追踪依赖链**：
   • 从入口目标开始，逐层展开依赖关系。
   • 示例：
     ```makefile
     program: main.o utils.o
         gcc -o program main.o utils.o

     main.o: main.c utils.h
         gcc -c main.c

     utils.o: utils.c utils.h
         gcc -c utils.c
     ```
`program` 依赖 `main.o` 和 `utils.o` → 检查这两个 `.o` 文件的生成规则。

3. **分析变量和宏**：
   • 查找 `CC`、`CFLAGS`、`LDFLAGS` 等编译选项的定义。
   • 示例：
     ```makefile
     CFLAGS = -Wall -O2
     ```

4. **理解特殊规则**：
   • `.PHONY`、条件判断（`ifeq`）、函数（`$(wildcard *.c)`）等高级用法。

5. **验证命令逻辑**：
   • 确保每条命令的输入输出和依赖关系正确。

#### **3. 示例解读**
```makefile
CC = gcc
CFLAGS = -Wall
TARGET = program
SRC = main.c utils.c
OBJ = $(SRC:.c=.o)  # 将 .c 替换为 .o

all: $(TARGET)

$(TARGET): $(OBJ)
    $(CC) $(CFLAGS) -o $@ $^

%.o: %.c
    $(CC) $(CFLAGS) -c $< -o $@

clean:
    rm -f $(OBJ) $(TARGET)
```
• **入口**：`all` 依赖 `program`。
• **依赖链**：`program` → `main.o` 和 `utils.o` → 自动匹配 `%.o` 规则生成。
• **变量**：`CC` 定义编译器，`CFLAGS` 定义编译选项。

#### **4.对%.o: %.c的讲解**
%.o: %.c​是匹配所有 .c 文件生成对应的 .o 文件
以上述makefile示例举例，当执行 `make` 时：
1. Makefile 发现需要构建 `main.o` 和 `utils.o`（由 `$(OBJ)` 变量定义）。
2. ​**​自动匹配 `%.o: %.c` 规则​**​：
    - 对于 `main.o`：
        - `%` 匹配字符串 `main`。
        - 依赖文件为 `main.c`（将 `%.c` 中的 `%` 替换为 `main`）。
    - 对于 `utils.o`：
        - `%` 匹配字符串 `utils`。
        - 依赖文件为 `utils.c`（将 `%.c` 中的 `%` 替换为 `utils`）。
3. 规则展开：每个 `.o` 目标的规则会被展开为：
```makefile
main.o: main.c
    gcc -Wall -c main.c -o main.o

utils.o: utils.c
    gcc -Wall -c utils.c -o utils.o
```


## 三、如何阅读 CMakeLists.txt
#### **1. 核心语法与结构**
• **项目配置**：
  ```cmake
  cmake_minimum_required(VERSION 3.10)  # 最低 CMake 版本
  project(MyProject)                    # 项目名称
  ```

• **变量与选项**：
  ```cmake
  set(CMAKE_CXX_STANDARD 11)       # 设置 C++ 标准
  option(ENABLE_TEST "Build tests" ON)  # 定义选项
  ```

• **目标定义**：
  ```cmake
  add_executable(myapp main.cpp)   # 定义可执行文件
  add_library(mylib STATIC utils.cpp)  # 定义静态库
  ```

• **依赖管理**：
  ```cmake
  target_link_libraries(myapp PRIVATE mylib)  # 链接库
  target_include_directories(myapp PUBLIC include)  # 头文件路径
  ```

• **条件控制**：
  ```cmake
  if(UNIX)
    add_definitions(-DUSE_POSIX)
  endif()
  ```

#### **2. 阅读步骤**
4. **识别项目结构**：
   • 查看 `project()` 定义和 `add_subdirectory()` 调用，了解模块划分。
     ```cmake
     project(MyApp LANGUAGES CXX)
     add_subdirectory(src)      # 子目录模块
     ```

5. **分析编译目标**：
   • 查找 `add_executable()`、`add_library()` 定义的核心构建目标。
   • 示例：
     ```cmake
     add_executable(myapp main.cpp utils.cpp)
     ```

6. **追踪依赖关系**：
   • 通过 `target_link_libraries()` 和 `find_package()` 查看外部依赖。
     ```cmake
     find_package(OpenCV REQUIRED)
     target_link_libraries(myapp PRIVATE OpenCV::OpenCV)
     ```

7. **检查编译选项**：
   • 查看 `target_compile_options()`、`add_definitions()` 等设置的标志。
     ```cmake
     target_compile_options(myapp PRIVATE -Wall -Wextra)
     ```

8. **理解条件逻辑**：
   • 分析 `if()`、`option()` 和平台检测（如 `WIN32`、`APPLE`）的分支逻辑。
```cmake
     if(MSVC)
         target_compile_definitions(myapp PRIVATE _CRT_SECURE_NO_WARNINGS)
     endif()
```

9. **验证生成过程**：
   • 确定 CMake 如何生成 Makefile 或 IDE 工程文件（如 `cmake -B build -S .` → `cd build && make`）。

#### **3. 示例解读**
```cmake
cmake_minimum_required(VERSION 3.12)
project(MyApp LANGUAGES CXX)

set(CMAXX_STANDARD 11)

add_executable(myapp main.cpp utils.cpp)

target_include_directories(myapp PUBLIC include)

find_package(OpenCV REQUIRED)
target_link_libraries(myapp PRIVATE OpenCV::OpenCV)

if(WIN32)
    target_compile_definitions(myapp PRIVATE WIN32_LEAN_AND_MEAN)
```
• **项目配置**：要求 CMake 3.12+，使用 C++11。
• **目标**：构建 `myapp`，包含 `main.cpp` 和 `utils.cpp`。
• **依赖**：链接 OpenCV 库，Windows 平台定义宏。


## 四、对比总结

| **特征**               | **Makefile**                                      | **CMakeLists.txt**                              |
|------------------------|--------------------------------------------------|------------------------------------------------|
| **编写方式**           | 直接定义编译命令和依赖关系                       | 声明式描述构建目标、依赖和选项                 |
| **跨平台支持**         | 需手动处理不同平台的差异                         | 自动生成平台相关的构建文件（如 Makefile、VS工程）|
| **可维护性**           | 低（需手动管理复杂依赖）                         | 高（模块化、条件分支）                         |
| **学习曲线**           | 简单（基础规则易学）                             | 较陡峭（需掌握 CMake 语法和生成逻辑）          |
| **适用           | 小型项目、快速原型                               | 中大型项目、跨平台开发                          |


## 五、工具链关系
```
CMakeLists.txt 
    → [CMake 生成] → Makefile / Visual Studio 工程 / Xcode 工程 
        → [Make / MSBuild / Xcode 编译] → 可执行文件
```

---
