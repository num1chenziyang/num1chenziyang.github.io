---
title: （实战）8.New_Start_V6-x86_64
date: 2025-04-03 13:27:25
categories:
  - SDLC编译工作
  - 编译实战
tags:
  - 编译
password: 9761565829chen
---
# （前言）机器详情

| 2025-03-28 |                |                     |
| ---------- | -------------- | ------------------- |
| ipv4       | 172.16.3.40    | ifconfig            |
| 架构         | zncgsl6        | uname -a            |
| 处理器        | 虚拟机            | 虚拟机                 |
| 系统         | NeoKylin（中标麒麟） | cat /etc/os-release |
| 机房位置       | 实体机位置          | 172.16.3.20华为机      |
| 密码         | root           | Big4ifmx            |

---
# （一）机器搭建
## 一.镜像下载
产品没有提供相应的镜像文件，需要自己找
https://www.gd-linux.com/


## 二.虚拟机搭建
对于 x86_64 而言，vmware 和 qemu+kvm 都可以搭建其虚拟机，本项目中两种方法都试了，分别都有问题，最后用 vmware 搭建完毕。

| 搭建方式     | 现象               | 解决方法                                      |
| -------- | ---------------- | ----------------------------------------- |
| vmware   | 安装完成后，重启，在黑屏页面卡死 | 需要uefi引导                                  |
| qemu+kvm | 键盘无法使用           | 安装的时候virt-manager添加硬件那里<br>添加虚拟键盘和鼠标（未尝试） |

其他问题同 aarch64 处。

---

# （二）编译环境搭建
见内部文章：[[1.项目编译环境搭建]]

---

# （三）代码适配
本项目出现的问题类型比较集中，所以按照问题类型进行记录。
## 一.重复定义错误（C++）
c++编译中，有几个 cpp 文件定义了两套同名函数，即：
```c++
int czy(int a);
int czy(int a,char *b);    //这里重载没问题

#ifdef XXXX                //但是如果又进入了 ifdef，则重复定义
int czy(int a);
int czy(int a,char *b);
#endif
```
现在是修改了 ifdef，让其无法生效。不过具体的原因最好深入研究一下。


## 二.g++添加-std=c++98（C++）
编译 c++模块的时候，有好几种报错都是在编译命令中添加-std=c++98解决的。
### 1.looser throw specifier
在 C++ 中，​**looser throw specifier** 错误通常发生在虚函数重写（override）时，​**派生类函数的异常规范（exception specification）比基类更宽松**，违反了 C++ 的类型安全规则。

我是添加了-std=c++98后通过，也有改代码的方式，但是不建议直接改代码。

### 2.error: no match for 'operator<<\*\*\*'
某些库特性需要更高标准的支持（如自定义类型自动推导）：
```bash
g++ -std=c++98 your_code.cpp -o output
```
总之是指定了-std=c++98后，就能 match 到了。

### 3.error: narrowing conversion（窄化转换，C++）
指定了-std=c++98后，问题解决。


## 三.gcc 添加-llzma
### 1.undefined reference to lzma_stream_decoder
​**未正确链接 LZMA 库**​（`liblzma`）导致的，在编译中指定：-llzma 即可。


## 四.-no-keep-memory 前添加 -Wl
在编译过程中，`-Wl` 是 GCC/Clang 等编译器的选项前缀，用于将后续参数**直接传递给链接器**​（如 `ld`）。而 `-no-keep-memory` 是 GNU 链接器（`ld`）的一个选项，用于控制链接时的内存使用行为。两者的组合通常出现在编译命令中，目的是优化链接阶段的内存消耗。

有一处-no-keep-memory前并未添加-Wl，有报错，添加后通过。


## 五.添加头文件
### 1.undefined reference to major
解决方法：添加头文件
```c
#include <sys/types.h>
#include <sys/sysmacros.h>
```

---

# （四）特殊问题记录
## 一.python脚本问题

| 信息                                                                            | 解决方法                     |
| ----------------------------------------------------------------------------- | ------------------------ |
| Use of assignment to $\[ is deprecated at /usr/cm/......./getopts.pl line 19. | 把getopts.pl 的第 19 行注了就过了 |


## 二.编译log掺杂脚本信息
```log
source /usr/share/Modules/init/bash;
else
echo "Cannot switch to Modules $swname version, command not found";

vim setup.out 会看到更多的杂乱的脚本信息，不仅仅是/usr/share/Modules/init/bash中的
```

中兴新支点系统/etc/profile.d/下，相较于别的系统多了一些脚本，自动设置了很多环境变量。在 build/pe_bert 中，setup 步骤取了一次env，导致 setup.out 中包含了 env 中杂乱的脚本信息，groklog setup.out 会有如上报错。

解决方法就是把/etc/profile.d/下的脚本改名备份。

| 原文件                        | 备份                             |
| -------------------------- | ------------------------------ |
| /etc/profile.d/modules.sh  | /etc/profile.d/modules.sh_bak  |
| /etc/profile.d/which2.sh   | /etc/profile.d/which2.sh_bak   |
| /etc/profile.d/scl-init.sh | /etc/profile.d/scl-init.sh_bak |



