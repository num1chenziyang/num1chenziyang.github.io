---
title: 2.重做bltfprcc.c流程
date: 2025-04-06 22:09:28 
categories: 
- SDLC流程记录
- 
tags: 
- 编译
password: 9761565829chen
---
# 一.总述

## 1.gen_bltfprcc 工具介绍

（1）此工具是由gen_bltfprcc.c 编译出来的工具，其依赖于bltfprcc.c（麻烦就麻烦在这）  
（2）现在 363 的 gen 是最初的，O15 的 gen 经过改动，会额外加入 ifdef ORA 大写 endif  
即 O15 的 gen 编出的bltfprcc.c 内容会比 363 多大约一倍  
（3）
   

## 2.bltfprcc 系列文件介绍

（1）bltfinit.c，定义新函数类型，往往是加入三个参数以上的函数时需要定义新类型（参考 to_date）。  
（2）bltfinit.h，extern 新类型。  
（3）bltfprcc.in，内建函数基础信息文件。  
（4）bltfprcc.c，gen_bltfprcc 工具处理 bltfprcc.in 后生成的文件。
   

## 3.bltfprcc.in 文件解析

TYPES  
int  
varchar  
FUNCTIONS  
to_date 1 NONE NONE 0 290 todate_datetime  
FUNCTIONS WITH_2ND_ARG **char**  
to_date 2 NONE NONE 0 290 todate_datetime  
FUNCTIONS WITH_2ND_ARG **char_char**  
to_date 3 NONE NONE 0 290 todate_datetime
 
一个参数  
datetime to_date(int a1);  
datetime to_date(varchar a1);
 
两个参数  
datetime to_date(int a1, char a2);  
datetime to_date(varchar a1, char a2);
 
三个参数  
datetime to_date(int a1, char a2, char a3);  
datetime to_date(varchar a1, char a2, char a3);
 
to_date 1 NONE NONE 0 290 todate_datetime  
函数名为 to_date，参数为 1 个，ID 为 290，返回类型为 datetime  
FUNCTIONS：**一个参数，类型为 TYPES 下的所有**  
FUNCTIONS WITH_2ND_ARG char：**两个参数，第一个为 TYPES 下，第二个为 char**  
FUNCTIONS WITH_2ND_ARG char_int：**三个参数，第一个为 TYPES 下，第二个为 char，第三个为 int**
    
# 二.重做 bltfprcc.c 流程

## 1.加入新的内建函数

（1）在bltfprcc.in 中加入新的内建函数。  
（2）编译make，其中 gen_bltfprcc 工具就会编译出来。注意，此时编译出来的gen_bltfprcc依赖于当前的bltfprcc.c 文件。  
（3）使用命令：./gen_bltfprcc bltfprcc.in，生成 bltfprcc.c.new 文件。  
（4）查看 bltfprcc.c.new 文件是否正确。可以看最终的范围是否合理，如何是 4000 多肯定是不正常的；可以找到 plus、minus 等函数的范围，查看其是否准确。  
（5）确定 bltfprcc.c.new 文件正确，替换掉tristarm/turbo下的 bltfprcc.c 文件。
   

## 2.修改之前的内建函数

由于 gen_bltfprcc 工具是依赖于 bltfprcc.c 的，所以导致修改之前的内容变得十分繁琐。  
（1）回退到不包含待修改函数的提交，重新编译到 make（为了得到一个之前的 gen_bltfprcc 工具）  
（2）向 bltfprcc.in 加入修改后的函数，以及函数之后的所有其他函数，执行./gen_bltfprcc bltfprcc.in  
（3）查看 bltfprcc.c.new 是否正确，然后将 bltfprcc.in 和 bltfprcc.c.new 备份出来。  
（4）回到最新提交，将bltfprcc.c.new 替换为bltfprcc.c，重新编译到 make（为了得到一个现在的 gen_bltfprcc 工具），将备份出来的 bltfprcc.in 替换现在的 bltfprcc.in，执行./gen_bltfprcc bltfprcc.in，若新出来的 bltfprcc.c.new 与 bltfprcc.c 完全一致，则说明修改成功。
   

## note：

1.倘若此 bltfprcc.in 中，包含大量 plus 和 minus 函数，在回退到不包含待修改函数的提交时，需要合并畅泉对 gen_bltfprcc.c 的提交（bind var bug:fix mantis5254 bug.），此提交改大了 gen_bltfprcc.c 中一些数组的大小，避免了在加入大量 plus 和 minus 函数后造成的混乱（包含大量 plus 和 minus 函数必须合，不包含也可以合）。
 
2.对于 O15 来说：  
（1）gen_bltfprcc.c 新增了大写功能，函数由一套小写变成了两套大小写，编号不变（函数编号还是到 2000 多），内容翻倍。如果在 bltfprcc.c 是两套大小写的情况下执行./gen_bltfprcc bltfprcc.in，则新生成的 bltfprcc.c.new 函数编号到 4000 多，这是肯定不对的。  
（2）正确做法是，先在 gen_bltfprcc.c 不包含大写功能的时候，做好一套小写的 bltfprcc.c ，然后将其替换到包含大写功能的目标提交，基于此一套小写的bltfprcc.c ，编出来 gen_bltfprcc 工具，然后执行./gen_bltfprcc bltfprcc.in，出来的 bltfprcc.c.new 就是两套大小写的状态了。
 
3.总之多检查几组函数的编号范围，自己改动的函数编号和类型都正确，就说明改动没什么问题。