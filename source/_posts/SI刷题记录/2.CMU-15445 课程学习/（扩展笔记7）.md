# 一.索引实现

索引是通过一种优化的方式来组织某些列的值和它们对应的数据行位置的信息，以便于快速检索。

## 1.索引的工作机制

（1）**索引条目**：索引通常包含两部分信息：  
键值（Key Value）：这是你选择创建索引的列上的值。例如，如果你为employee_id列创建索引，那么索引将包含该列中出现的所有ID值。  
指针/引用（Pointer/Reference）：这指向了实际存储在表中的对应记录的位置。这个位置可能是数据库页内的具体偏移量、行号或其他形式的标识符。
 
（2）**数据结构**：为了实现快速查找，索引通常是基于某种高效的数据结构构建的，比如B树或B+树。这些结构允许快速定位特定键值，并通过指针直接访问到相应的数据行。
 
note：  
除了那些作为索引键的部分之外，索引并不会完整地复制整个表的数据。它只存储了必要的键值和对原始数据行的引用。这意味着索引本身比原始表要小得多，特别是当索引是基于少数几个字段而不是整个表时。
   

## 2.索引举例说明

employees表，列如下：employee_id, first_name, last_name, department, salary。如果我们在这个表的employee_id列上创建了一个索引：  
（1）索引内容：每个employee_id及其对应的指向该员工详细信息所在位置的**指针**。￼例如，如果employee_id为101的记录位于数据库文件的第500页第10行，则索引中对于employee_id=101的条目可能看起来像这样：￼==Index Entry for employee_id=101:====￼====Key: 101====￼====Pointer: Page 500, Row 10==
 
（2）查找过程：当你执行一个查询如SELECT * FROM employees WHERE employee_id = 101;时，数据库系统首先使用索引来找到employee_id=101的指针，然后根据这个指针直接访问并读取该员工的全部信息。
   

## 3.key 和 value

### （1）Key（键）

- **定义**：在索引中，`key`指的是被索引列的值。例如，如果你为一个表的`employee_id`列创建了一个索引，那么这个列中的每一个值就是一个`key`。  
- **作用**：`key`用于定位数据行。通过比较查询条件与这些`key`值，数据库可以快速找到所需的数据行或确定数据行不存在。

### （2）Value（值）

- **定义**：在B+树索引的叶子节点中，`value`通常是指向实际数据行的指针或者说是引用。这可能是一个物理地址（如页号和行号），它告诉数据库管理系统在哪里可以找到对应于该`key`的实际数据行。

### （3）(非)聚集索引

对于聚集索引（Clustered Index），`value`实际上是整行的数据（或指向数据的直接引用），因为聚集索引决定了数据在磁盘上的物理存储顺序（具体数据内容）。而对于非聚集索引（Non-clustered Index），`value`通常是包含指向实际数据行位置的信息（指针）。  
==聚集索引：====就像书籍按照ISBN号有序排列在书架上一样，数据行按照某个键值顺序存储。这使得基于该键值的查询非常高效，但只能有一个这样的排序方式。==  
==非聚集索引：====如同图书馆的卡片目录，它提供了额外的查找路径而不改变实际书籍的物理位置。你可以有多个非聚集索引，以支持不同的查询需求，但每次查询需要两次查找：一次是查索引，另一次是从表中获取完整记录。==

### （4）示例说明

employees表，在这个表的employee_id列上创建索引：  
Key: 在这个例子中，`employee_id`就是`key`。比如，如果有一条记录的`employee_id`是101，那么101就是该记录对应的索引中的`key`。  
Value: 对于这条记录，`value`将是该记录在数据库文件中的具体位置信息（指针）（比如，页号500，行号10）。  
这意味着，当你知道`employee_id`=101时，你可以通过索引迅速找到该员工的具体信息所在的页和行，然后直接访问这些信息。
    
# 二.B+树在数据库中的应用（结合磁盘存储和索引设计）

## 1. 数据库的磁盘存储特性

数据库的数据通常存储在硬盘上，而硬盘的读写操作有以下特点：  
- **按页（Page）存取**：硬盘的最小读写单位是“页”（例如4KB、8KB），即使只读一个字节，也需要读取整个页。  
- **I/O代价高**：相比内存操作，硬盘I/O速度慢（毫秒级 vs 纳秒级），因此减少I/O次数是优化数据库性能的关键。
   

## 2. B+树的设计目标

B+树是一种多路平衡搜索树，专门针对磁盘存储优化，其核心目标是通过减少I/O次数来提高查询效率。以下是其关键设计特点：

![特 性 节 点 大 小 = 磁 盘 页 高 扇 出 (Fan- out) 数 据 集 中 在 叶 子 节 点 叶 子 节 点 链 表 连 接 说 明 每 个 B + 树 节 点 的 大 小 设 计 为 和 磁 盘 页 一 致 （ 例 如 4KB), 保 证 一 次 / 0 操 作 能 完 整 读 取 一 个 节 点 。 每 个 节 点 存 储 大 量 键 值 （ 例 如 几 百 个 ), 树 的 高 度 低 （ 通 常 3 一 4 层 就 能 存 储 百 万 级 数 非 叶 子 节 点 仅 存 储 索 引 键 （ 用 于 路 由 ） ， 所 有 数 据 记 录 存 储 在 叶 子 节 点 。 叶 子 节 点 通 过 双 向 指 针 串 联 ， 支 持 高 效 的 范 围 查 询 和 顺 序 扫 描 。 ](Exported%20image%2020250328134028-0.png)   
## 3. B+树在数据库索引中的使用步骤

### 3.1 B+树的物理结构

- **根节点（Root Node）**：树的顶层节点，指向子节点。  
- **内部节点（Internal Nodes）**：非叶子节点，存储键值和子节点指针。  
- **叶子节点（Leaf Nodes）**：存储实际数据（或数据指针）和相邻叶子节点的指针。
 
### 3.2 索引的构建过程

假设有一个数据库表 `user`，包含字段 `id`（主键）和 `name`，并在 `id` 上创建B+树索引：  
1. **分配根节点**：初始时，根节点是叶子节点，直接存储数据记录（或数据指针）。  
2. **插入数据**：  
- 当叶子节点填满时，分裂为两个节点，并向上层父节点插入新的键值。  
- 若父节点也满，继续分裂，直到根节点分裂（树的高度增加）。  
3. **最终结构**：  
- 根节点和内部节点存储键值和子节点指针。  
- 叶子节点存储数据记录的指针（如硬盘地址），并按主键顺序排列。
 
### 3.3 查询过程

- **等值查询（例如 `id=100`）**：  
1. 从根节点开始，逐层比较键值，找到目标叶子节点。  
2. 读取叶子节点对应的页到内存，找到 `id=100` 的记录指针。  
3. 根据指针访问数据所在的硬盘页。  
**总I/O次数**：树的高度（通常3-4次I/O）。
 
- **范围查询（例如 `id BETWEEN 50 AND 200`）**：  
1. 找到 `id=50` 的叶子节点。  
2. 通过叶子节点的链表指针，顺序扫描后续节点，直到 `id=200`。  
**优势**：避免了回溯到根节点，直接利用链表顺序访问。
   

## 4. 具体示例

数据库表：user(id INT PRIMARY KEY, name VARCHAR(20))  
索引结构：在 id 字段上构建 B+ 树索引，假设每个节点（页）存储4个键值。
 
B+树示意图

![[ 根 节 点 ] [ 1 2 ‰ 39 ] [ 1 ， 5 ， 9 ] [ 11 ， 15 ， 19 ] - 键 值 （ 路 由 作 用 ） [ 21 ， 25 ， 29 ， “ 内 部 节 点 “ 叶 子 节 点 存 储 数 据 指 针 叶 子 节 点 [1•datal[5•datal[9•data] （ 通 过 双 向 链 表 连 接 ） ](Exported%20image%2020250328134033-1.png)  

操作示例：  
1. **查询 `id=15`**：  
- 读取根节点（1次I/O），找到键值范围在 `10 ≤ 15 < 20`，进入第二个子节点。  
- 读取内部节点（第2次I/O），找到键值 `15` 对应的叶子节点。  
- 读取叶子节点（第3次I/O），找到 `id=15` 的数据指针。
 
2. **范围查询 `id BETWEEN 18 AND 25`**：  
- 找到 `id=18` 的叶子节点（3次I/O）。  
- 通过链表指针顺序扫描后续叶子节点，直到 `id=25`（无需返回根节点）。
   

## 5. B+树的优势总结

![优 势 减 少 | / 0 次 数 高 扇 出 低 高 度 顺 序 访 问 优 化 数 据 与 索 引 分 离 说 明 节 点 大 小 对 齐 磁 盘 页 ， 一 次 | / O 读 取 一 个 完 整 节 点 。 树 的 高 度 低 （ 百 万 数 据 仅 需 3 一 4 层 ), 减 少 查 词 时 的 次 数 。 叶 子 节 点 链 表 支 持 高 效 范 围 查 词 ， 适 合 BETWEEN 、 ORDER BY 等 操 作 。 非 叶 子 节 点 仅 存 储 键 值 ， 叶 子 节 点 存 储 数 据 指 针 ， 减 少 冗 东 存 储 。 ](Exported%20image%2020250328134035-2.png)   
## 6. 实际数据库中的应用

- **MySQL InnoDB**：默认使用B+树作为主键索引（聚集索引），数据直接存储在叶子节点。  
- **PostgreSQL**：支持B+树索引，叶子节点存储数据指针（堆元组的TID）。
 
通过B+树，数据库能够高效处理大规模数据的随机查询和范围查询，同时最小化硬盘I/O操作，这是其成为数据库索引主流数据结构的核心原因。