> [!caution] This page contained a drawing which was not converted.   

![Table Index B+ Tree B-Tree Family Tree B+ Tree Design Choices Optimizations Additional Index Usage Implicit Indexes Partial Indexes Covering Indexes Functional/Expression Indexes Skip Lists Radix Tree Radix Tree vs. Trie Binary Comparable Keys Inverted Indexes ](Exported%20image%2020250328134007-0.png)  
![CMU 15-445/645 DATABASE SYSTEMS Tree Indexes DBMS • Internal Meta-data • Core Data Storage • Temporary Data Structures Table Indexes table index : Table Index B+ Tree, Skip Lists, Radix Tree table index DBMS DBMS PöJLNÅG DBMS DBMS B+ Tree B-Tree Family B-Tree B Balanced, B-Tree Family Tree Balanced Tree 0 B-Tree wtRR*2—, Tree Blink Tree B* Tree B-Tree 5 B+ Tree B+ Tree key leaf nodes, B-Tree fi key *F-GFfififi5ficF0 B+ Tree B+ Tree searchs sequential insertions I-NIA deletions O(logn) , sequential access fi B+ Tree BST (Binary Search Tree) $JCjæ%ifi, children, disk-oriented database R}EF-fi5it, page I oaf M-way B+tree *Jf51J, M key, M+l children • B+ Tree perfectly balanced, leaf node • root i5ä, ED M/2- 1 #keys • inner node keys, k+l children • B+ Tree fi leaf nodes Xkffj}kJ sequential access B+ Tree Nodes B+ Tree node key key/value pairs, key table index column, value fiÅRfA5 node inner nodes leaf nodes leaf (E,äfiä2, • Record/Tuple Ids: tuple fi}äf+ • Tuple Data: tuple data leaf node Secondary_ DBMS index 9, Indexes 11th, leaf node siblings B+Tree Leaf Node Level Slots Prev Sorted Ke s K3 V ues B+ Tree Operations Insert leaf node, L 2. key/value pair L Next Kn parent node entry, % parent node root node Delete I. root HAå, entry ,6fi2h$J leaf node, L 2. hhlJß*ü entry 3. siblings entries, L 5tEJüäkJ sibling 4. parent node entry B+Tree fi Insert* Delete In Practice • Typical Fill-Factor: 67% Average Fanout = = 234 • Typical Capacities: Height 4: 312,900,721 entries Height 3: entries • Pages per level: Level I = Level 2 = I page = 134 pages = IMB 8KB = 140 MB Level 3 = 17956 pages Clustered Indexes Clustered Indexes table primary key EIIEb—'fiN table RÉEEÜ—T cluster indexa DBMSs table 31, primary key, DBMS DBMSs clustered indexeso Compound Index DBMS table index (B+ Tree), El] compound index, CREATE INDEX compound_idx ON table (a, b, c); condition SELECT FROM WHERE a SELECT FROM WHERE SELECT FROM WHERE a table = 5 AND b c table a 5 AND b 42; table 42 AND c < 77; condition DBMS hash index table index, (a, b, c) B+ Tree Design Choices Node Size iMäRih, disk Disk Type HDD SSD In-Memory node size : Node Size NIMB NIOKB -512B workload Merge Threshold merge DBMS merge table indexo Variable Length Keys Tree key Pointers: key 2. Variable Length Nodes: 3. Key Map: node key/val list Non-unique Indexes key Duplicate Keys: key 2. Value Lists: key values, *IL! chained hashing B* Tree Leaf Node Level Slots Prev Sorted Ke s V ues B+Tree Leaf Node Level Slots Prev Sorted Ke s Values Intra-node Search • Linear Scan • Binary Search • Interpolation: keys Optimizations Prefix Compression leaf node keys prefix, robbed robbing robot Prefix: rob bed bing ot , keys Suffix Truncation key Next K2 • ••CE] Next inner nodes inner nodes key, prefix abcdef hi • k Imno rstuv iBlälä Bulk Insert Tree fiN'lAfiitRN# keys fiWJ*E, Keys: 3, 7, 9, 13, 6, 1 Sorted Keys: 1, 3, 6, 7, 9, 13 IDImlHI Pointer Swizzling Nodes page id nodes DBMS page table nodes page buffer pool page G buffer pool Additional Index Usage Implicit Indexes itF# DBMSs index, • Primary Keys • Unique Constraints Foreign Keys foo table CREATE TABLE foo ( id SERIAL PRIMARY KEY, vall INT NOT NULL, va12 VARCHAR(32) UNIQUE CREATE TABLE bar ( id INT REFERENCES foo (vall) , integrity constraints, val VARCHAR(32) DBMS : CREATE UNIQUE INDEX foo_pkey CREATE INDEX ON CREATE UNIQUE INDEX foo_va12_ Partial Indexes table index, CREATE INDEX idx_foo ON foo (a, b) ON foo (id) ; foo (vall) ; key ON foo (va12) ; index primary keys -k/ / * foreign keys Unique Constraints 90 F Ffifi: WHERE c 'WuTang• ; indexes 558, Covering Indexes query Ffi*äkJFfifi column index * , DBMS tuple CREATE INDEX idx_foo ON foo (a, SELECT b FROM foo WHERE a = 123; b); index column CREATE INDEX idx foo ON foo (a, b) INCLUDE (c); (INDEX INCLUDE COLUMNS) : Functional/Expression Indexes index key column *fifi9åfi, SELECT * FROM users WHERE EXTRACT (dow FROM login) = 2 login CREATE INDEX ON users (EXTRACT(dow FROM login)); Skip Lists A -Ei$JfYB*, öJLNÅü! table index dynamic order-preserving $Jü (B+Tree, O(logn) dynamic order-preserving sorted linked list, Ffrä}kfffi O(n) , B+ Tree sorted linked list Ex, FjtöJfiEiRfk5 K4 Skip Listso 6.046 Skip Lists, Skip Lists Pros & Cons : • pros B+ Tree • Cons B+ Tree disk/cache Radix Tree Radix Tree vs. Trie radix tree Afi-EFjtEff4BEfi trie Trie E L A E ELLO Radix Tree VE Keys: HELLO, HAT, HAVE ](Exported%20image%2020250328134009-1.png)

（使用 B+ tree）

本质上就是一个小表，将大表的某些列抽取出来

一个直观展示数据结构的网站

![Data Structure Visualizations A bout Al rithms Known Bugs Feature Sts Java Version Flash Version Create Your Own Source Code co ntaCt David Galles Computer Science University Of San Francisco Currently, we have visualizations tor the following data structures and algorithms: o Stack: Array Implementation o Queues: Array Imp mentation queues; Linked List Implementation a Lists: Array Implementation (available in java version) o Lists: Linked List Implementation (available in java version) Recursion o Factorial o Reversing a String a N -Queens Problem • Indexing o Binary and Linear Search (of sorted list) o Search Trees o AVL Trees (Balanced binary search trees) a Red-Black Trees o Splay Trees o Open Hash Tables (Closed Addressing) o Closed Hash Tables (Open Addressing) o Closed Hash Tables, us•nq buckets a Trie (Prefix Tree. 26-arv,Tiee) o Radix Tree (CO BSI of children) o B Trees ](Exported%20image%2020250328134019-2.png)

**视频17****:0****0**