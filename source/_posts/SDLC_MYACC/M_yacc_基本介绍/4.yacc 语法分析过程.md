# 一.语法分析总述

Yacc 是一种用于生成 LR(1) 语法分析器的工具，主要应用于编译器和解释器的开发。LR(1) 分析是一种自下而上的语法分析方法，通过构建有限自动机来实现对源代码的语法检查和转换。Yacc 工具根据给定的文法规则生成相应的分析程序，帮助开发者快速构建复杂的语言处理器。
 
假设我们要创建一个编译器或解释器，那么我们首先要定义一套清晰的语言规范（即文法规则）。接着，我们可以利用像 Yacc 这样的工具来自动化地生成一个能够理解和翻译该语言的程序。这个程序在接收到用户提供的源代码后，会逐行扫描并将其转化为计算机可以直接运行的形式。
    
# 二.语法分析过程

## 1.过程详述

1. 输入读取：解析器从词法分析器（如Lex）接收词法单元。这些词法单元是由源代码转换而来的基本单位，比如关键字、标识符、运算符等。
2. 状态机：Yacc 生成了一个状态机，这个状态机由多个状态组成，每个状态对应一组可能的动作（如移进或规约）和向其他状态的转移。
3. 移进（Shift）：当解析器遇到一个新的词法单元时，它可能会选择将这个词法单元“移进”到内部的数据结构（通常是栈）中。这相当于将这个词法单元暂时存储起来，等待进一步处理。
4. 规约（Reduce）：当解析器识别出栈顶的某些词法单元可以按照某个文法规则组合成一个非终结符时，它会执行规约操作。这意味着解析器将根据文法规则将这些词法单元替换为该规则左侧的非终结符，并将这个非终结符推回到栈中。规约操作本质上是将多个较小的部分合并成一个较大的整体。
5. 冲突解决：在某些情况下，解析器可能面临选择困难，比如不知道应该移进还是规约（移进/规约冲突），或者不知道应该使用哪个规约规则（规约/规约冲突）。Yacc 提供了一些默认的解决方案，例如在移进/规约冲突中，默认选择移进，在规约/规约冲突中，默认选择最早定义的规则。
6. 接受（Accept）：当整个输入被成功解析，且解析器处于接受状态时，解析过程结束，表明输入符合文法规则。
7. 错误处理：如果解析过程中遇到不符合文法规则的输入，解析器将尝试恢复到一个可以继续解析的状态。这通常涉及到跳过一些输入词法单元，直到找到一个可以恢复解析的点。
   

## 2.示例

假设有一个简单的文法规则，用于解析加法表达式：  
==expr: expr== =='+'== ==term====￼== ==| term====￼====;====￼====term: NUMBER====￼====;==  
在这个例子中，expr 和 term 是非终结符，NUMBER 是一个词法单元，代表数字。当解析器遇到一个 NUMBER 时，它可以先将其作为 term 推入栈中。如果接下来又遇到一个 NUMBER，并且在这两个 NUMBER 之间有一个 '+'，那么解析器可以将这两个 NUMBER 以及 '+' 按照第一条规则规约为一个 expr。  
Yacc 的规约过程是解析器的核心机制之一，通过这种机制，Yacc 能够将复杂的输入逐步解析为文法规则定义的结构。
   

## 3.详细示例

假设我们有一个简单的算术表达式文法，用于解析加法和乘法表达式。我们的目标是理解如何通过 Yacc 的语法分析步骤来解析这样的表达式。

### 1.文法定义

首先，定义一个简单的文法：  
==expr: expr== =='+'== ==term { $$ === ==$1== ==+== ==$3====; }====￼== ==| term { $$ === ==$1====; }====￼== ==;==  
==term: term== =='*'== ==factor { $$ === ==$1== ==*== ==$3====; }====￼== ==| factor { $$ === ==$1====; }====￼== ==;==  
==factor: NUMBER { $$ === ==$1====; }====￼== ==|== =='('== ==expr== ==')'== =={ $$ === ==$2====; }====￼== ==;==
 
### 2.解析过程

假设我们要解析的表达式是 3 + 4 * 2。  
1. 初始化

- 栈：空
- 输入：3 + 4 * 2

2. 移进（Shift）

- 栈：3
- 输入：+ 4 * 2

3. 规约（Reduce）

- 栈：3
- 输入：+ 4 * 2
- 动作：根据规则 factor: NUMBER，将 3 规约为 factor。
- 栈：factor

4. 再次移进（Shift）

- 栈：factor
- 输入：+ 4 * 2

5. 移进（Shift）

- 栈：factor +
- 输入：4 * 2

6. 移进（Shift）

- 栈：factor + 4
- 输入：* 2

7. 规约（Reduce）

- 栈：factor + 4
- 输入：* 2
- 动作：根据规则 factor: NUMBER，将 4 规约为 factor。
- 栈：factor + factor

8. 再次移进（Shift）

- 栈：factor + factor
- 输入：* 2

9. 移进（Shift）

- 栈：factor + factor *
- 输入：2

10. 移进（Shift）

- 栈：factor + factor * 2
- 输入：空

11. 规约（Reduce）

- 栈：factor + factor * 2
- 输入：空
- 动作：根据规则 factor: NUMBER，将 2 规约为 factor。
- 栈：factor + factor * factor

12. 规约（Reduce）

- 栈：factor + factor * factor
- 输入：空
- 动作：根据规则 term: term * factor，将 factor * factor 规约为 term。
- 栈：factor + term

13. 规约（Reduce）

- 栈：factor + term
- 输入：空
- 动作：根据规则 expr: expr + term，将 factor + term 规约为 expr。
- 栈：expr

14. 接受（Accept）

- 栈：expr
- 输入：空
- 动作：解析成功，最终结果为 3 + (4 * 2) = 11。
 
### 3.图形化表示

==初始状态：====￼====栈：[]====￼====输入：3 + 4 * 2==  
==移进 3：====￼====栈：[3]====￼====输入：+ 4 * 2==  
==规约 3 为 factor：====￼====栈：[factor]====￼====输入：+ 4 * 2==  
==移进 +：====￼====栈：[factor, +]====￼====输入：4 * 2==  
==移进 4：====￼====栈：[factor, +, 4]====￼====输入：* 2==  
==规约 4 为 factor：====￼====栈：[factor, +, factor]====￼====输入：* 2==  
==移进 *：====￼====栈：[factor, +, factor, *]====￼====输入：2==  
==移进 2：====￼====栈：[factor, +, factor, *, 2]====￼====输入：[]==  
==规约 2 为 factor：====￼====栈：[factor, +, factor, *, factor]====￼====输入：[]==  
==规约 factor * factor 为 term：====￼====栈：[factor, +, term]====￼====输入：[]==  
==规约 factor + term 为 expr：====￼====栈：[expr]====￼====输入：[]==  
==接受：====￼====栈：[expr]====￼====输入：[]==
 
### 4.过程总结

通过上述步骤，可以看到 Yacc 的解析器是如何逐步将输入的词法单元（tokens）规约为文法规则定义的结构。每一步的移进和规约操作都是基于当前栈顶的状态和输入的下一个词法单元来决定的。最终，当整个输入被成功解析并规约为文法的起始符号时，解析过程结束。