# 一.% 与 %%

在 YACC 文件中，% 和 %% 是用来分隔不同部分的特殊符号。它们的作用如下：

## 1.% 符号

==%== ==符号用于定义 YACC 文件的声明部分。这部分通常包括以下内容：==

1. ==C 语言代码块：用== ==%{ ... %}== ==包围的 C 语言代码块，通常用于包含头文件、定义全局变量和函数等。==
2. ==类型声明：用== ==%union== ==定义联合体，用于指定语法规则中使用的数据类型。==
3. ==词法分析器返回的 token：用== ==%token== ==定义词法分析器返回的终结符及其类型。==
4. ==非终结符类型：用== ==%type== ==定义非终结符的数据类型。==
   

## 2.%% 符号

==%%== ==符号用于分隔 YACC 文件的声明部分和规则部分。具体来说：==

- ==第一个== ==%%====：表示声明部分结束，规则部分开始。==
- ==第二个== ==%%====：表示规则部分结束，用户定义的 C 语言代码块开始（这部分通常是可选的）。==
   

## 3.举例解释

==1. C 语言代码块==  
==%{====￼====#include <stdio.h>====￼====#include <stdlib.h>====￼====#include <string.h>==  
==// 假设词法分析器返回的 token 类型====￼====#define SELECT 258====￼====#define FROM 259====￼====#define IDENTIFIER 260====￼====%}==  
==这部分用== ==%{ ... %}== ==包围的 C 语言代码块，用于包含必要的头文件和定义宏。==
 
==2. 类型声明==  
==%====union== =={====￼== ==char== ==*str;====￼====}==  
==这部分定义了一个联合体，用于指定语法规则中使用的数据类型。在这个例子中，定义了一个== ==char *== ==类型的成员== ==str====。==
 
==3. 词法分析器返回的 token==  
==%====token <str> IDENTIFIER====￼====%====token SELECT FROM==  
==这部分定义了词法分析器返回的终结符及其类型。====<str>== ==表示== ==IDENTIFIER== ==的类型是== ==char *====。==
 
==4. 非终结符类型==  
==%====type== ==<====str====> select_list table_name==  
==这部分定义了非终结符的数据类型。====select_list== ==和== ==table_name== ==的类型是== ==char *====。==
 
==5. 规则部分==  
==%%====￼====select_statement:====￼== ==SELECT select_list FROM table_name====￼== =={====￼== ==printf====(===="Parsed SELECT statement: SELECT %s FROM %s\n"====,== ==$2====,== ==$4====);====￼== ==}====￼====;==  
==select_list:====￼== ==column_name====￼== =={====￼== ==$$ = strdup(====$1====);====￼== ==}====￼====| select_list== ==','== ==column_name====￼== =={====￼== ==char *result = (char *)malloc(strlen(====$1====) + strlen(====$3====) + 2);====￼== ==sprintf(result,== =="%s,%s"====,== ==$1====,== ==$3====);====￼== ==free(====$1====);====￼== ==free(====$3====);====￼== ==$$ = result;====￼== ==}====￼====;==  
==column_name:====￼== ==IDENTIFIER====￼== =={====￼== ==$$ = strdup(====$1====);====￼== ==}====￼====;==  
==table_name:====￼== ==IDENTIFIER====￼== =={====￼== ==$$ = strdup(====$1====);====￼== ==}====￼====;====￼====%%==  
==这部分定义了文法规则。每个规则由一个非终结符、一个或多个终结符或非终结符组成，后面可以跟一个动作（C 语言代码片段）。==
    
# 二." | "

在你提供的上下文中，| 符号用于定义语法解析规则中的选择（alternatives）。这是 Yacc 或 Bison 语法文件中常见的一种用法。具体来说，| 符号表示在解析某个非终结符时，可以有多种不同的匹配方式。

## 1.举例：

==select_list:====￼== ==column_name====￼== =={====￼== ==// 动作：处理单个列名====￼== ==$$ = strdup($====1====);== ==// 将列名复制到结果中====￼== ==}====￼====|====￼== ==select_list== ==','== ==column_name====￼== =={====￼== ==// 动作：处理多个列名====￼== ==char== ==*result = (====char== ==*)====malloc====(====strlen====($====1====) +== ==strlen====($====3====) +== ==2====);====￼== ==sprintf====(result,== =="%s,%s"====, $====1====, $====3====);====￼== ==$$ = result;====￼== ==}==  
==解释==

1. ==select_list: column_name==
    
    - ==这条规则表示== ==select_list== ==可以由一个== ==column_name== ==组成。==
    - ==动作部分== =={ ... }== ==表示当解析器匹配到这种形式时，执行的动作是将== ==column_name== ==复制到结果中。==
2. ==|==
    
    - ==|== ==符号表示== ==select_list== ==还有另一种可能的形式。==
3. ==select_list ',' column_name==
    
    - ==这条规则表示== ==select_list== ==也可以由另一个== ==select_list====、一个逗号== ==,== ==和一个== ==column_name== ==组成。==
    - ==动作部分== =={ ... }== ==表示当解析器匹配到这种形式时，执行的动作是将两个字符串（====$1== ==和== ==$3====）连接起来，并在中间加上逗号。==

==假设输入是一个 SQL 查询中的列选择部分，比如== ==col1, col2, col3====。==

- ==解析器首先会匹配== ==col1====，并将其赋值给== ==select_list====。==
- ==然后解析器会遇到逗号和== ==col2====，这时它会匹配== ==select_list ',' column_name== ==规则，将== ==col1== ==和== ==col2== ==连接起来，形成== ==col1,col2====。==
- ==接下来解析器会再次遇到逗号和== ==col3====，再次匹配== ==select_list ',' column_name== ==规则，将== ==col1,col2== ==和== ==col3== ==连接起来，最终形成== ==col1,col2,col3====。==
   

## 2.总结

==|== ==符号在这里的作用是定义== ==select_list== ==的两种可能形式：==

- ==一个单独的== ==column_name====。==
- ==一个== ==select_list== ==后面跟着一个逗号和一个== ==column_name====。==

这两种形式通过 | 符号连接在一起，表示 select_list 可以是其中任何一种形式。
    
# 三.$1 $2 $3 $4 $$

在 Yacc 或 Bison 语法文件中，$1, $2, $3, $4 等符号用于引用当前规则中各个部分的值。这些符号被称为“值栈”或“符号栈”，它们允许你在动作（action）中访问和操作解析器匹配到的各个部分。
 
## 1.示例一：

==expression:====￼== ==expression== =='+'== ==expression { $$ === ==$1== ==+== ==$3====; }====￼====| expression== =='-'== ==expression { $$ === ==$1== ==-== ==$3====; }====￼====| NUMBER { $$ === ==$1====; }====￼====;==  
**解释**

1. ==expression: expression '+' expression==
    
    - ==这条规则表示== ==expression== ==可以由两个== ==expression== ==和一个== ==+== ==组成。==
    - ==动作部分== =={ $$ = $1 + $3; }== ==表示将第一个== ==expression== ==的值（====$1====）和第三个== ==expression== ==的值（====$3====）相加，并将结果赋值给个== ==expression====（====$$====）。==
2. ==expression: expression '-' expression==
    
    - ==这条规则表示== ==expression== ==可以由两个== ==expression== ==和一个== ==-== ==组成。==
    - ==动作部分== =={ $$ = $1 - $3; }== ==表示将第一个== ==expression== ==的值（====$1====）减去第三个== ==expression== ==的值（====$3====），并将结果赋值给整个== ==expression====（====$$====）。==
3. ==expression: NUMBER==
    
    - ==这条规则表示== ==expression== ==可以由一个== ==NUMBER== ==组成。==
    - ==动作部分== =={ $$ = $1; }== ==表示将== ==NUMBER== ==的值直接赋值给整个== ==expression====（====$$====）。==

==符号栈的含义==

- ==$$====: 表示当前规则的值，即整个规则匹配的结果。==
- ==$1====: 表示规则中的第一个符号的值。==
- ==$2====: 表示规则中的第二个符号的值。==
- ==$3====: 表示规则中的第三个符号的值。==
- ==$4====: 表示规则中的第四个符号的值。==
- ==依此类推。==
 
## 2.示例二：

==select_list:====￼== ==column_name====￼== =={====￼== ==// 动作：处理单个列名====￼== ==$$ = strdup($====1====);== ==// 将列名复制到结果中====￼== ==}====￼====|====￼== ==select_list== ==','== ==column_name====￼== =={====￼== ==// 动作：处理多个列名====￼== ==char== ==*result = (====char== ==*)====malloc====(====strlen====($====1====) +== ==strlen====($====3====) +== ==2====);====￼== ==sprintf====(result,== =="%s,%s"====, $====1====, $====3====);====￼== ==$$ = result;====￼== ==}====￼====;==  
**详细解释**  
**select_list:**

1. ==column_name==
    
    - ==这条规则表示== ==select_list== ==可以由一个== ==column_name== ==组成。==
    - ==动作部分== =={== **$$** === strdup(====$1====); }== ==表示将== ==column_name== ==的值（====$1====）复制到结果中（====$$====）。==
2. ==select_list ',' column_name==
    
    - ==这条规则表示== ==select_list== ==也可以由另一个== ==select_list====、一个逗号== ==,== ==和一个== ==column_name== ==组成。==
    - ==动作部分== =={ char *result = (char *)malloc(strlen($1) + strlen($3) + 2); sprintf(result, "%s,%s", $1, $3); $$ = result; }== ==表示：==
        
        - ==$$====: 整个== ==select_list== ==的值。==
        - ==$1====: 第一个== ==select_list== ==的值。==
        - ==$2====: 逗号== ==,====（虽然在这个例子中没有使用== ==$2====）。==
        - ==$3====:== ==column_name== ==的值。==
    - ==动作部分的具体操作是将== ==$1== ==和== ==$3== ==连接起来，并在中间加上逗号，然后将结果赋值给== ==$$====。==

==总结==

- ==$$====: 当前规则的值。==
- ==$1====,== ==$2====,== ==$3====,== ==$4====: 规则中各个部分的值，按顺序编号。==
    
# 四.%type 和 %token

在Yacc的文法文件中，%type 和 %token 是两个重要的声明，它们用于定义非终结符和终结符。

## 1.%token

==%token== ==用于声明==**终结符**==，也就是====在文法中不再细分的基本符号====。这些通常对应于词法分析器（如Lex或Flex）产生的标记（tokens）。例如，如果一个语言中有加号== ==+== ==和整数== ==INTEGER====，那么可以在Yacc文件中这样声明：==  
==%====token PLUS INTEGER==  
==这里，====PLUS== ==和== ==INTEGER== ==都是词法分析器识别出来的具体符号。当Yacc解析器遇到这些符号时，会将它们视为基本元素进行处理。==
 
## 2%.type

==%type== ==用于声明非终结符的数据类型，即文法中的规则左侧符号。==**非终结符**==是可以在文法中进一步展开的符号====。通过== ==%type== ==声明，可以指定每个非终结符关联的值类型，这对于构建抽象语法树（AST）或其他形式的解析结果非常有用。例如：==  
==%====type== ==<====int====> expr==  
==这个例子表示== ==expr== ==规则的结果应该是一个整数。这意味着每当== ==expr== ==被解析时，与之相关的动作可能会返回一个整数值，这个值会被存储起来供后续使用。==
 
## 3.示例

==假设我们有一个简单的算术表达式解析器，它可以解析加法和整数。我们可以这样写Yacc文件的一部分：==  
==%{====￼====#include <stdio.h>====￼====%}==  
==%token INTEGER====￼====%token PLUS====￼====%type <====int====> expr==  
==%%==  
==expr: INTEGER====￼== ==| expr PLUS expr { $$ = $====1== ==+ $====3====; }====￼== ==;==  
==%%==  
==int== ==main====()== =={====￼== ==return== ==yyparse();====￼====}==  
==int== ==yyerror====(====char== ==*s)== =={====￼== ==fprintf====(====stderr====,== =="%s\n"====, s);====￼== ==return== ==0====;====￼====}==  
==在这个例子中：==

- ==%token INTEGER== ==和== ==%token PLUS== ==定义了两个终结符。==
- ==%type <int> expr== ==定义了非终结符== ==expr== ==的数据类型为整型。==
- ==在== ==expr== ==规则中，===={ $$ = $1 + $3; }== ==是一个动作，它计算两个表达式的和并将结果赋给当前表达式的值。==

通过这样的声明和规则，Yacc可以正确地解析输入并执行相应的操作。